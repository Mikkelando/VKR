


 algorithm/optimization_loop.gms

$if not "%1"=="1" $abort "Not set starting-time <t=1> in coalitions_t_sequence"

# Generate equations list 
EQUATIONS
$batinclude "modules" "eql"
;

# Generate equations logic
$batinclude "modules" "eqs"

MODEL  CO2 /
$batinclude "modules" "eql"
/;
CO2.optfile = 1;
CO2.SCALEOPT = 1;

# ................................................
# PROGRESSIVE OPTIMIZATIONS LOOOP 
# ................................................
$label loop0
$if "a%1"=="a" $goto loop1
 
# Fixing variables loading last gdxfix intermediate solution
# Not avaiilable durng first iteraton: skip it
$ifthen.skipfirst not "a%1" == "a1"
$setglobal tfix %1

* <ondotl> option activates or deactivates the automatic addition 
* of the attribute .L to variables on the right-hand side of assignments. 
* It is most useful in the context of macros
$ondotl
$batinclude "modules" 'fix_variables'
$offdotl
$endif.skipfirst


##  SOLVING OPTIONS
#_________________________________________________________________________
# PARALLELIZATION
#.........................................................................
# See https://www.gams.com/latest/docs/UG_GamsCall.html#GAMSAOsolvelink
# AsyncThreads := in-memory parallel (6)
# AsyncGrid    := in-file parallel (3)
# loadLibrary  := in-memory serial (5)
# chainScript  := in-file serial (0)
#.........................................................................
$setglobal solvelink %solvelink.AsyncThreads%
*$setglobal solvelink %solvelink.AsyncGrid%
*$setglobal solvelink %solveLink.loadLibrary%
*$setglobal solvelink %solveLink.chainScript%

# SOLVER OPTIONS
$setglobal iterlim 99900
option sysout         = on        ;
option solprint       = on        ;
option iterlim        = %iterlim% ;
option reslim         = 99999     ;
option solprint       = on        ;
option limrow         = 0         ;
option limcol         = 0         ;
option holdFixedAsync = 1         ; 


* prints solution listing when asynchronous solve (Grid/Threads) is used
$if set only_solve option AsyncSolLst = 1;

##  LAUNCH SOLVER
#_________________________________________________________________________
$batinclude "algorithm/solve_regions"

$shift
$goto loop0
# ................................................
# END PROGRESSIVE OPTIMIZATIONS LOOOP 
# ................................................
$label loop1
;


 algorithm/solve_regions.gms

*starting settings
viter(iter,v,t,n) = 0;
max_solution_change = %convergence_tolerance%;
converged = 0;

scalar debug_readyCollect;
scalar iternum;
file fx;
put fx;

$if not set solvermode $setglobal solvermode nlp

*///////////////////////////////////////////////////////////////////////////////
*                                 MAIN LOOP
*///////////////////////////////////////////////////////////////////////////////
* loop on iter set
* continue looping unless "converged" becomes 1
* If max_iterations number is reached, an abort command will interrupt the loop

loop(iter$(not converged),

* Reset collection loop
clt_problem(clt) = no;
timer = TimeElapsed;

$batinclude "modules" "before_solve"


CO2.solvelink = %solvelink%; # Solving optios
                             # i.e., < 3 > means solving in an async grid
                             # GAMS will generate model, submit to solver and then
                             # proceed in parallel without waiting for the solution.


** SUBMISSION LOOP
*..................................................
* Step 1: every coalition evaluates its best alone-solution
$if set only_solve cltsolve(clt) = no; cltsolve('%only_solve%') = yes;
loop(clt$(cltsolve(clt)), # only active coalitions
    reg(nn) = yes$map_clt_n(clt,nn);  # Set <reg> to one single region per loop and then
                                      # solve the model (every equation constrained by reg(n)
                                      # is executed only for reg-current regions )
    solve CO2 maximizing UTILITY using %solvermode%;
    h(clt) = CO2.handle;  # Model-attribute <handle> contains an unique identification for each submitted
                        # solution. The handle values stored in h(c) are then used to collect
                        # solutions once processes are completed.
);






** COLLECTION LOOP
*..................................................
* Completed jobs are collected until:
* no more pending jobs left (card(h) is 0) OR timeout expires
repeat

    debug_readyCollect = readyCollect(h);  # Waits until a model solution is ready to be collected.
                                           #  0: One or more of the requested jobs is/are ready
                                           #  1: There is no active job to wait for.
                                           # >1: Troubles!
    abort$(debug_readyCollect gt 1) 'ERROR: problem waiting for coalition to solve';



    ## Handle-collect loop
    loop(clt$(cltsolve(clt) and handlecollect(h(clt))), # HandleCollect tests for the solution status:
                                                # 1: solution available
                                                # 0: otherwise

        execute_loadhandle CO2;  # Update GAMS database with solution for the current instance of CO2-model

        solrep(iter,clt,'solvestat') = CO2.solvestat;  # save solvestat  (1 is ok)
        solrep(iter,clt,'modelstat') = CO2.modelstat;  # save modelstat  (1 or 2 is optimal or locally opt)
        solrep(iter,clt,'ok')        =  (not ((CO2.solvestat gt 1) or (CO2.modelstat gt 2)));



        abort$handledelete(h(clt)) 'ERROR: problem deleting handles' ;   # solution should have been removed
                                                                       # at this stage!




        # :::::  CHECK IF ANY REGION HAS PROBLEM TO SOLVE  ::::: #

        if((not solrep(iter,clt,'ok')),
        # In <solrep> i have saved reference of any possible troubling region.
        # I can solve it serially to see if trouble can be overcome.


                # I give to any troubling coalition a limited number of serial attempt
                # to reach a convergence
                if( solretry(iter,clt) < %max_solretry%,
                    solretry(iter,clt) = solretry(iter,clt) + 1;

                    # Set solving region
                    reg(nn) = yes$map_clt_n(clt,nn);

                    # Launch serially the model
                    solve CO2 maximizing UTILITY using %solvermode%;
                    h(clt) = CO2.handle;  # Model-attribute <handle> contains an unique identification for each submitted
                                        # solution. In this way i notify the <handlecollect(h)> of the inner loop i've
                                        # finished my serial solving.


                # Aaargh! Some coalition has run out of its allowed serial attempts!
                else
                    h(clt) = no;
                    clt_problem(clt) = yes; # save coalition in "problem" shame-list
                );

        # Region solved correctly
        else
            h(clt)=0;
        ); # end of problematic coalitions management
    );# end of handlecollect loop


until ((card(h) eq 0) or ((timeelapsed-timer) gt %max_seconds%));
# END of collection loop
* Completed jobs are collected until:
* EITHER no more pending jobs left (card(h) is 0) OR timeout expires




** POST-COLLECTION
*..................................................
* Check that every parallel job has been managed properly

* If card(h) is not empty at this stage,
* it means that timeout has expired.
abort$(card(h) gt 0) 'ERROR: TIME OUT, %max_seconds% seconds elapsed and not all solves are complete';

* Re-run problematic regions (if any) serially
if(card(clt_problem) gt 0,
    display clt_problem;
    CO2.solvelink = %solveLink.loadLibrary%;
    loop(clt_problem(clt),
        reg(nn) = yes$map_clt_n(clt,nn);
        solve CO2 maximizing UTILITY using %solvermode%;
    );
    CO2.solvelink = %solvelink%;

    # save its result in a debug-output and terminate process
    execute_unload 'debug_infeas.gdx';
    abort 'ERROR: regions unable to be solved to optimality';
);


*===============================================================================
*                       CONVERGENCE RULE
*===============================================================================


viter(iter,'S',t,n)$nsolve(n)   = S.l(t,n);    # Keep track of last investment values
viter(iter,'MIU',t,n)$nsolve(n) = MIU.l(t,n);  # Keep track of last mitigation values

allerr(iter,v) = smax((t,n)$nsolve(n), abs(viter(iter,v,t,n)-viter(iter-1,v,t,n))); 


* Evaluate distance measure for convergence
* max_solution_change among all regions and all times between eiter(i,..) and eiter(i-1,..)
max_solution_change$(ord(iter) gt 1) = smax(v$vcheck(v), allerr(iter,v));
max_solution_change_iter(iter) = max_solution_change;
*display max_solution_change;


** Convergence rule:
* this max_solution_change must be under a specific threshold
* CONVERGENCE TOLERANCE could be set!
converged$(
$if %policy%=="cbudget_regional" $if %burden%=="cost_efficiency" ( abs(cbudget_2020_2100 - ctax_target_rhs) le %conv_budget%) and
    (sum(cltsolve, solrep(iter,cltsolve,'ok')) eq card(cltsolve)) and 
    (max_solution_change lt %convergence_tolerance%) and 
    (ord(iter) ge %miniter%))
    = 1;

** Weights may change AFTER FIRST ITERATION
$if %region_weights% == 'negishi' nweights(t,n)$((not converged)) = %calc_nweights%;

* Update the model propagating all needed infos
$batinclude "modules" "after_solve"

* For every iteration dump current situation (even if not converged)
$if set all_data_temp put_utility 'gdxout' / 'all_data_temp_%nameout%.gdx' ; execute_unload;

);
# end of main-loop

** FAILURE
*........................................................................
* if still converged = 0
abort$(not converged) 'Still not converged after all iterations';



 algorithm.gms

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================
* launch optimization logic, passing full sequence of coalition-changing-times
* This will result in a sequence of progressive optimizations, 
* one for each %coalitions_t_sequence% time passed
$batinclude "algorithm/optimization_loop" %coalitions_t_sequence%





 modules/cooperation_coalitions.gms

* COOPERATION COALITIONS
* Define coalitions mappings
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

** COALITIONS GDXFIX
*$setglobal gdxfix "results_default"

# This is to be sure to initialize the sequence
$setglobal coalitions_t_sequence 1

$setglobal solmode 'noncoop'

## REGION WEIGHTS
$if %region_weights% == 'negishi' $setglobal calc_nweights ((CPC.l(t,n)**elasmu)/sum(nn, (CPC.l(t,nn)**(elasmu))))

* Population weights
$if %region_weights% == 'pop' $setglobal calc_nweights 1


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

* Some pre-defined coalitions
* in a policy file this set can be extended with new coalitions

* to implement an srm_coalition use the flag %coalition_folder% and 
* put the files inside data_srm_coalition/%coalition_folder%/map_clt_n.inc 
* and data_srm_coalition/%coalition_folder%/cltsolve.inc

SET clt "List of all possibly-applied coalitions" /
# Single-region coalitions
$include %datapath%n.inc
# European Union
eu27
noneu27
# Grand coalition (all)
grand
srm_coalition
coal_a
coal_b
coal_c
coal_d
coal_e
/;

* Some pre-defined coalitions mapping
* in a policy file this set can be extended with new coalitions
SET map_clt_n(clt,n) "Mapping set between coalitions and belonging regions" /
$ifthen.regionselected %n%=="ed57"
# Single-region coalition
arg.arg
aus.aus
aut.aut
bel.bel
bgr.bgr
blt.blt
bra.bra
can.can
chl.chl
chn.chn
cor.cor
cro.cro
dnk.dnk
egy.egy
esp.esp
fin.fin
fra.fra
gbr.gbr
golf57.golf57
grc.grc
hun.hun
idn.idn
irl.irl
ita.ita
jpn.jpn
meme.meme
mex.mex
mys.mys
nde.nde
nld.nld
noan.noan
noap.noap
nor.nor
oeu.oeu
osea.osea
pol.pol
prt.prt
rcam.rcam
rcz.rcz
rfa.rfa
ris.ris
rjan57.rjan57
rom.rom
rsaf.rsaf
rsam.rsam
rsas.rsas
rsl.rsl
rus.rus
slo.slo
sui.sui
swe.swe
tha.tha
tur.tur
ukr.ukr
usa.usa
vnm.vnm
zaf.zaf
# European Union
eu27.(aut, bel, bgr, cro, dnk, esp, fin, fra, grc, hun, irl, ita, nld, pol, prt, rcz, rfa, rom, rsl, slo, swe, blt)
# Non-EU27
noneu27.(gbr, arg, aus, bra, can, chl, chn, cor, egy, golf57, idn, jpn, meme, mex, mys, nde, noan, noap, nor, osea, rcam, ris, rjan57, rsaf, rsam, rsas, rus, sui, tha, tur, ukr, usa, vnm, zaf, oeu)
# Grand coalitions (all)
grand.(aut, bel, bgr, cro, dnk, esp, fin, fra, grc, hun, irl, ita, nld, pol, prt, rcz, rfa, rom, rsl, slo, swe, blt, gbr, arg, aus, bra, can, chl, chn, cor, egy, golf57, idn, jpn, meme, mex, mys, nde, noan, noap, nor, osea, rcam, ris, rjan57, rsaf, rsam, rsas, rus, sui, tha, tur, ukr, usa, vnm, zaf, oeu)
$elseif.regionselected %n%=="witch17"
# Single-region coalition
brazil.brazil
canada.canada
china.china
europe.europe
india.india
indonesia.indonesia
jpnkor.jpnkor
laca.laca
mena.mena
mexico.mexico
oceania.oceania
sasia.sasia
seasia.seasia
southafrica.southafrica
ssa.ssa
te.te
usa.usa
# European Union
eu27.(europe)
# Non-EU27
noneu27.(brazil,canada,china,india,indonesia,jpnkor,laca,mena,mexico,oceania,sasia,seasia,southafrica,ssa,te,usa)
# Grand coalitions (all)
grand.(brazil,canada,china,europe,india,indonesia,jpnkor,laca,mena,mexico,oceania,sasia,seasia,southafrica,ssa,te,usa)
$endif.regionselected
$if set coalition_folder $include %datapath%data_srm_coalition/%coalition_folder%/map_clt_n.inc
/;

# Control set for active coalitions
SET cltsolve(clt) /
$if set coalition_folder $include %datapath%data_srm_coalition/%coalition_folder%/cltsolve.inc
/;

$ifthen.srm not set coalition_folder
* Initialized to no
cltsolve(clt) = no;

cltsolve('eu27') = yes;
cltsolve('noneu27') = yes;
$endif.srm
# MACRO mapping between coalitions and belonging regions (probaby now obsolete due to changes in solver)
$macro mapclt(n)    map_clt_n(&clt,n)
$macro mapcclt(nn)  map_clt_n(&clt,nn)


##  BEFORE SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='before_solve'

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

clt
map_clt_n
cltsolve


$endif.ph



 modules/cooperation_coop.gms

* COOPERATION COALITIONS
* Define coalitions mappings
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

* REGION WEIGHTS
* | negishi | pop |
$setglobal region_weights 'pop'

$setglobal solmode 'coop'

$setglobal coalitions_t_sequence 1

## REGION WEIGHTS
$if %region_weights% == 'negishi' $setglobal calc_nweights ((CPC.l(t,n)**elasmu)/sum(nn, (CPC.l(t,nn)**(elasmu))))

* Population weights
$if %region_weights% == 'pop' $setglobal calc_nweights 1


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SET clt "List of all possibly-applied coalitions" /
*$include %datapath%n.inc
grand
/;

SET map_clt_n(clt,n) "Mapping set between coalitions and belonging regions";
map_clt_n('grand',n) = yes;

# Control set for active coalitions
SET cltsolve(clt);
* Initialized to no
cltsolve('grand') = yes;

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

clt
map_clt_n

$endif.ph



 modules/cooperation_noncoop.gms

* COOPERATION COALITIONS
* Define coalitions mappings
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

$setglobal calc_nweights 1

$setglobal coalitions_t_sequence 1


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SET clt "List of all possibly-applied coalitions" /
$include %datapath%n.inc
/;

SET map_clt_n(clt,n);
map_clt_n(clt,n)$sameas(clt, n) = YES;


# Control set for active coalitions
SET cltsolve(clt);
* Initialized to no 
cltsolve(clt) = yes;

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

clt
map_clt_n

$endif.ph



 modules/core_algorithm.gms



# CORE ALGORITHM
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

# CONVERGENCE
* Maximum number of iterations
$setglobal maxiter 100
* Minimum number of iterations
$setglobal miniter 4
$setglobal convergence_tolerance 1e-1
$setglobal max_seconds 300 #5 minutes
$setglobal max_seconds 60*60 #1 hour
$setglobal max_solretry 100


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SETS
* Sets needed for parallelized solving procedure
    iter    'Iterations for solving'               / i1*i%maxiter% /
    v       'Variables to check for convergence'   / MIU, S /
    vcheck(v)  'Variables that are actually chacked, others just reported' / MIU, S /
    clt_problem(clt) 'Coalitions that were not solved'
    irep 'Report items for solrep' / solvestat, modelstat, ok /
;


## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

SCALAR converged    '1 if model converged, 0 otherwise'  ;
converged = 0;

PARAMETERS
    viter(iter,v,t,n)                'Keep track of last utility values to check for convergence'
    allerr(iter,v)                   'Remaining difference or error in viter values'
    max_solution_change              'Max relative diff wrt last utility values'
    max_solution_change_iter(iter)   'Max relative diff wrt last utility values'
    h(clt)                           'Model handles for parallel computing of regions'
    solrep(iter,*,irep)              'Model stats report in the non-coop case'
    solretry(iter,*)                 'Number of times a region was solved in a given iter'
    timer                            'Time elapsed at the beginning of iter'
;

solrep(iter,clt,irep) = na;
solretry(iter,clt) = 0;

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

viter
allerr
max_solution_change_iter
solrep
converged
elapsed

$endif.ph


 modules/core_economy.gms

* CORE ECONOMY MODULE
* -
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

## CONF
*-------------------------------------------------------------------
* Definition of the global flags and settings specific to the module
$ifthen.ph %phase%=='conf'

* SAVINGS RATE
* | fixed | flexible |
$setglobal savings 'fixed'

*SSPs have been updated to 2020 based on Koch and Marian (2021), so no update anymore needed
*$setglobal update_ssp_by_historical

#MACRO: Load from the same parameter but with first ssp index. Name starts with ssp_
$macro load_from_ssp(par,idx,ssp,suxfile) \
parameter ssp_&par(*,&&idx); \
execute_loaddc '%datapath%data_&suxfile' ssp_&par; \
&par(&&idx) = ssp_&par('&ssp',&&idx);


##  CALIBRATED CONF ------------------------------------
# These settings shouldn't be changed

* Default options
$setglobal default_prstp   0.015
$setglobal default_elasmu  1.45
$setglobal default_savings "fixed"

* Run the model on PPP or MMM
*| PPP | MER |
$setglobal exchange_rate 'PPP'


## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing
* sets the element that you need.
$elseif.ph %phase%=='sets'

SET
    ssp     'SSP baseline names'       / ssp1,ssp2,ssp3,ssp4,ssp5 /
    gdpadj  'GDP-adjustment type'      / PPP,MER /
;

set prodfact /labour,capital/;


## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'


PARAMETERS
* Population and technology
    dk              'Depreciation rate on capital (per year)'         /  0.100     /
    prodshare(prodfact, n) 'production elasticity in the Cobb-Douglas function'

* Savings Rate
    dice_opt_savings  'Gross Savings Rate level as DICE convergence'   /  0.2751    /  # DICE2016 optim savings convergence!
;


PARAMETERS
* Savings rate
    optlr_savings(n)   'Optimal long-run Savings Rate used for transversality'
    fixed_savings(t,n) 'Gross Savings Rate value if S variable is fixed [%GDP]'

* Other rates
    ga(t,n)            'Growth rate of Productivity from'
    gl(t,n)            'Growth rate of Labor'

* World values
    world_c(t)
    world_y(t)
    world_ygross(t)
    world_ynet(t)
    world_k(t)
    world_avg_s(t)
;

prodshare('labour', n) = 0.7;
prodshare('capital', n) = 0.3;


##  PARAMETERS LOADED ----------
parameter ykali(t,n) 'GDP for the dynamic calibration [T$]';
load_from_ssp(ykali,'t,n',%baseline%,baseline)

parameter l(t,n) 'Population [million people]';
parameter pop(t,n) 'Population [million people]';
load_from_ssp(l,'t,n',%baseline%,baseline)

parameter gdppc_kali(t,n) 'GDP per capita used for calibration [MER]';
gdppc_kali(t,n) = ykali(t,n) / l(t,n) * 1e6;
parameter basegrowthcap(t,n)          'GDPcap baseline growth factor';

* Adjust population and GDP data until present to historical values maintaining GDP per capita growth
$ifthen.vd set update_ssp_by_historical
$gdxin %datapath%data_validation
parameter ykali_valid(t,n), l_valid(t,n);
$loaddc ykali_valid=ykali_valid_wdi l_valid=l_valid_wdi
parameter i_valid(*,t,n);
$loaddc i_valid=i_valid_wdi
$gdxin
parameter lrate(t,n);
parameter gdppcrate(t,n);
loop((t,tp1)$(pre(t,tp1)),
  lrate(tp1,n) = l(tp1,n) / l(t,n);
  gdppcrate(tp1,n) =  gdppc_kali(tp1,n) / gdppc_kali(t,n);
);
l(t,n)$(year(t) le 2015) = l_valid(t,n);
gdppc_kali(t,n)$(year(t) le 2015) = ykali_valid(t,n) / l_valid(t,n) * 1e6;
loop((t,tp1)$(pre(t,tp1) and (year(tp1) gt 2015)),
  l(tp1,n) = l(t,n) * lrate(tp1,n);
  gdppc_kali(tp1,n) = gdppc_kali(t,n) * gdppcrate(tp1,n);
);
$endif.vd
# Recompute actual quantities used:
ykali(t,n)$gdppc_kali(t,n) = gdppc_kali(t,n) * l(t,n) / 1e6;
pop(t,n) = l(t,n);

* Conversion factors between PPP and MER
$gdxin %datapath%data_baseline
parameter ppp2mer(t,n) 'ratio to convert PPP to MER';
$loaddc ppp2mer
$gdxin
parameter mer2ppp(t,n) 'ratio to convert MER to PPP';
mer2ppp(t,n) = 1 / ppp2mer(t,n);
#PPP adjustment in case
$if %exchange_rate%=="PPP" ykali(t,n) = ykali(t,n) * mer2ppp(t,n); gdppc_kali(t,n) = gdppc_kali(t,n) * mer2ppp(t,n);


## STARTING CAPITAL AND SAVINGS RATE
* Take from  calibrated file the capital zero as GDP weighted total capital.
PARAMETERS
    s0(*,t,n)      'Regions Savings Rate at starting time [%GDP]'
    k0(*,t,n)      'Initial Regions Capital at starting time [Trill 2005 USD]'
;

$gdxin '%datapath%data_validation.gdx'
$load k0=k_valid_article, s0=socecon_valid_weo_mean
$gdxin
$if %exchange_rate%=="PPP" k0('fg',t,n) = k0('fg',t,n)*mer2ppp(t,n);
*for regions with missing capital, impute based on estimated linar relationship with GDP (R squared = 0.9604)
k0('fg','1',n)$(k0('fg','1',n) eq 0) = 2.72 * ykali('1',n) + 0.127;
s0('savings_rate', '1', n) = max(s0('savings_rate', '1', n), 1) / 100; #in percent, for negative value set to 1% to avoid negative capital
#use: k0('fg', '1', n) and s0('savings_rate', '1', n)


##  PARAMETERS EVALUATED ----------

PARAMETER
* Starting values
   q0(n)              'Starting (2015) GDP for each region [Trill 2005 USD]'
   e0(n)              'Initial (2015) emissions per each Region [GtCO2-eq]'
* Total factor productivity
   tfp(t,n)           'Regions Total Factor Productivity'
   i_tfp(t,n)         'Baselines Investments to evaluate TFP'
   k_tfp(t,n)         'Baselines Capital to evaluate TFP'
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

* Starting GDP
q0(n) = ykali('1',n) ;

 ##  BASELINE PER-CAPITA GROWTH ------------------------
* Baseline per-capita growth
basegrowthcap(t,n) = ((( (ykali(t+1,n)/pop(t+1,n)) / (ykali(t,n)/pop(t,n)) )**(1/tstep)) - 1 )$(t.val < card(t))  ; # last value set to 0

##  SAVINGS RATE --------
* Optimal long-run Savings rate
optlr_savings(n) = (dk + .004)/(dk + .004*elasmu + prstp)*prodshare('capital',n);

* Evaluate converging Savings Rate
* Linear interpolation: S0 + (Send - S0)*(t - t0)/(tend - t0)
fixed_savings(t,n) = s0('savings_rate', '1', n) + (optlr_savings(n) - s0('savings_rate', '1', n)) * (t.val - 1)/(card(t) - 1);


##  DYNAMIC CALIBRATION OF TFP FROM BASELINE AND SCENARIO ---------------------
* set capital first value
k_tfp('1',n)  =  k0('fg', '1', n);

* retrieve tfp from reverting the Cobb-Douglas Production Function based on fixed investment rates iteratively
loop(t,
   # Investments
   i_tfp(t,n)  =  fixed_savings(t,n)  * ykali(t,n)   ;
   # Capital
   k_tfp(t+1,n)  =  ((1-dk)**tstep) * k_tfp(t,n)  +  tstep * i_tfp(t,n)  ;
   # TFP of current scenario (explicited from Cobb-Douglas prod. function)
   tfp(t,n)  =  ykali(t,n) / {
                                 (
$if set mod_government            working_hours('1',n)/5278 * employment_rate('1',n)/100 *     
                                  pop(t,n)/1000
                                 )**prodshare('labour',n) *
                                 k_tfp(t,n)**prodshare('capital',n) *
$if set mod_natural_capital      (gnn**natural_capital_global_elasticity(n)) * (natural_capital_aggregate(n,'mN'))**prodshare('nature',n) *
                                 1
                              };

);


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
    C(t,n)            'Consumption (%exchange_rate%) [Trill 2005 USD / year]'
    CPC(t,n)          'Per capita consumption (%exchange_rate%) [2005 USD per year per capita]'

    K(t,n)            'Capital stock (%exchange_rate%) [Trill 2005 USD / year]'
    I(t,n)            'Investments (%exchange_rate%) [Trill 2005 USD / year]'
    S(t,n)            'Gross Savings Rate as fraction of gross world product [%GDP]'
    RI(t,n)           'Real Interest Rate (per annum)'

    YGROSS(t,n)       'GDP GROSS (%exchange_rate%) [Trill 2005 USD / year]'
    YNET(t,n)         'GDP NET of climate impacts (%exchange_rate%) [Trill 2005 USD / year]'
    Y(t,n)            'GDP NET of Abatement Costs and Damages (%exchange_rate%) [Trill 2005 USD / year]'

    CTX(t,n)          'Carbon Tax effect on GDP (%exchange_rate%) [Trill 2005 USD]'
;
POSITIVE VARIABLES  Y, YNET, YGROSS, C, CPC, K, I, S;

# VARIABLES STARTING LEVELS
* to help convergence
 YGROSS.l(t,n) = ykali(t,n)  ;
   YNET.l(t,n) = ykali(t,n)  ;
      Y.l(t,n) = ykali(t,n)  ;
      S.l(t,n) = fixed_savings(t,n)  ;
      I.l(t,n) = S.l(t,n) * ykali(t,n)  ;
      C.l(t,n) = ykali(t,n) - I.l(t,n)  ;
    CPC.l(t,n) = C.l(t,n) / pop(t,n)  * 1e6;
      K.l(t,n) = k_tfp(t,n) ;
      RI.l(t,n) = 0.05;

##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

##  STABILITY CONSTRAINTS --------
* to avoid errors/help the solver to converge
       C.lo(t,n) = 1e-8; # needed because of eq_periodu (!! higher than 1e-7 -> infes risk!)
     CPC.lo(t,n) = 1e-8; # needed because of eq_ri (!! higher than 1e-6 -> infes risk!)
  YGROSS.lo(t,n) = 1e-8; # needed because of eq_damfrac (higher than 1e-4 -> infes risk)
       K.lo(t,n) = 1e-8; # needed because of eq_komega (!! higher than 1e-7 -> infes risk)
       S.up(t,n) = 1;    # by definition
       S.lo(t,n) = 0;    # by definition
#.................................................
# NOTE
# Hardest experiments tested:
# < ssp1 noncoop LRdiff prstp=0.03>
# < ssp3 noncoop LRdiff *>
# < ssp5 noncoop LRdiff prstp=0.03>
#.................................................

UTARG.lo(t,n)=1e-8;

# STARTING CAPITAL ----------
K.fx(tfirst,n) = k0('fg', '1', n);


# SAVINGS RATE ----------
$ifthen.sav  %savings%=='fixed'
* Savings are fixed to evaluated converging trends
  S.fx(t,n) = fixed_savings(t,n)  ;
$else.sav
* Savings are left free to be optimized
* They are fixed to optimal DICE value only for last 10 periods
* to avoid end-of-world-effects
  S.fx(last10(t),n) = optlr_savings(n)  ;
* Fix starting point
  S.fx(tfirst,n) = s0('savings_rate', '1', n)  ;
$endif.sav


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

    eq_ygross     # Output gross equation
    eq_yy         # Output net equation
    eq_ynet       # Output GDP net of damages equation

    eq_cc         # Consumption equation
    eq_cpc        # Per capita consumption definition

    eq_s          # Savings rate equation
    eq_ri         # Interest rate equation
    eq_kk         # Capital balance equation

##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

* GDP gross: Cobb-Douglas production function
eq_ygross(t,n)$(reg(n) and ord(t) gt 1)..  YGROSS(t,n)  =E=  tfp(t,n) * (K(t,n)**prodshare('capital',n)) * 
                                            [
$if set mod_natural_capital                  GLOBAL_NN(t,n) ** natural_capital_global_elasticity(n) * NAT_CAP_DAM('market',t,n)**prodshare('nature',n) * 
                                            (
$if set mod_government                       LABOUR(t,n)*
                                             pop(t,n)/1000)**prodshare('labour',n)]
;

* GDP net of Climate Damages
$ifthen.dam set damages_postprocessed
 eq_ynet(t,n)$(reg(n))..  YNET(t,n)  =E=  YGROSS(t,n) - DAMAGES.l(t,n)  ;
$else.dam
eq_ynet(t,n)$(reg(n))..  YNET(t,n)  =E=  YGROSS(t,n) - DAMAGES(t,n)  ;
$endif.dam

* GDP net of both Damages and Abatecosts
 eq_yy(t,n)$(reg(n))..   Y(t,n)  =E=  YNET(t,n)
                                      # CO2 Abatement Costs
                                  -   ABATECOST(t,n)
                                      # CO2 Carbon Tax [Trill USD / GtCO2]
                                  -   ctax_corrected(t,n) * 1e-3 * (E(t,n) - E.l(t,n))

$ifthen.oghg %climate% == 'witchoghg'
                                      # OGHG Abatement Costs
                                  -   sum(oghg,  ABATECOST_OGHG(oghg,t,n) )
                                      # OGHG Carbon Tax [Trill USD / GtCO2eq]
                                  -   ctax(t,n) * sum(oghg, EOGHG(oghg,t,n) - EOGHG.l(oghg,t,n))
$endif.oghg

$ifthen.gov set mod_government
                                  -   TAX('capital',t,n) * RI.l(t,n)*K(t,n)
                                  -   TAX('labour',t,n) * MPL(t,n) * (pop(t,n)/1000) * LABOUR(t,n)
                                  +   GOV_EXP(t,n)
                                  -   ctax(t,n) * E.l(t,n)  #to undo the default lump-sum redistirbution of the ctax
$endif.gov

                                       # Cost of SRM Geoengineering
$if set mod_srm                   -    SRM_COST(t,n)

$if set mod_dac                   -    COST_CDR(t,n)
;

* Investments
 eq_S(t,n)$(reg(n))..   I(t,n)  =E=  S(t,n) * Y(t,n)
;

* Consumption
 eq_cc(t,n)$(reg(n))..   C(t,n)  =E=  Y(t,n) - I(t,n) 
$if set mod_adaptation                - sum(g, I_ADA(g,t,n))
$if set mod_natural_capital           - sum(type, NAT_INV(type,t,n))
;

* Consumption pro-capite (in thousands USD)
 eq_cpc(t,n)$(reg(n))..   CPC(t,n)  =E=  C(t,n) / pop(t,n) * 1e6 ;

* Capital according to depreciation and investments
 eq_kk(t+1,n)$(reg(n))..   K(t+1,n)  =E=  (1-dk)**tstep * K(t,n) + tstep * I(t,n)   ;

* Interest rate
 eq_ri(t+1,n)$(reg(n))..   RI(t,n)  =E=  ( (1+prstp) * (CPC(t+1,n)/CPC(t,n))**(elasmu/tstep) ) - 1  ;



##  AFTER SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='after_solve'

 world_c(t)            = sum(n$( nsolve(n)),      C.l(t,n));
 world_y(t)            = sum(n$( nsolve(n)),      Y.l(t,n));
 world_ygross(t)       = sum(n$( nsolve(n)), YGROSS.l(t,n));
 world_ynet(t)         = sum(n$( nsolve(n)),   YNET.l(t,n));
 world_k(t)            = sum(n$( nsolve(n)),      K.l(t,n));
 world_avg_s(t)        = sum(n$( nsolve(n)),      S.l(t,n))/card(nsolve);


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  REPORT
$elseif.ph %phase%=='report'


* Social Cost of Carbon
Parameter
    scc(t,n)           'Social Cost of Carbon' 
;
* Evaluate social cost of carbon per region through marginals as in DICE
$if %cooperation%=="coop" scc(t,n) = div0(-1e3*eq_e.m(t,n),eq_cc.m(t,n)); #this is regional, not global (emissions at only within its own reagion considered unless cooperative!)
$if %cooperation%=="noncoop" scc(t,n) = -1e3*sum(nn, div0(eq_e.m(t,nn) , eq_cc.m(t,nn)) );


# LOCAL DAMAGES ----------------------------------------
PARAMETERS
* Damages fraction
    damfrac_ygross(t,n) 'Damages over GDPgross [%GDPgross]: (-) damage (+) gain'
* Damages absolute
    damages_ygross(t,n) 'Absolute damages over GDPgross [Trill 2005 USD]: (-) damage (+) gain'
;
 damfrac_ygross(t,n) = ((YNET.l(t,n) - YGROSS.l(t,n))/YGROSS.l(t,n) * 100 ) ;
 damages_ygross(t,n) = YNET.l(t,n) - YGROSS.l(t,n)  ;

# WORLD DAMAGES ----------------------------------------
PARAMETERS
  world_damfrac(t)  'World damages [%]'
  world_damages(t)  'World damages [Trill 2005 USD]'
;
 world_damfrac(t) = sum(n,YGROSS.l(t,n))/sum(n,YNET.l(t,n)) - 1;
 world_damages(t) = sum(n,YGROSS.l(t,n)) - sum(n,YNET.l(t,n));


##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Sets (excl. aliases) ---------------------------------
ssp
gdpadj

# Parameters -------------------------------------------
ykali
ppp2mer
pop
l
basegrowthcap
tfp
elasmu
prstp
prodshare
dk
scc
rr
ga
gl
damfrac_ygross
damages_ygross
world_damfrac
world_damages

# Variables --------------------------------------------
C
CPC
K
I
S
RI
YGROSS
YNET
Y
CTX

# Equations -------------------
eq_cc

$endif.ph




 modules/core_emissions.gms

* EMISSIONS MODULE
*
* Where Regions emissions are determined.
*____________
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
#
## CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module
$ifthen.ph %phase%=='conf'

* MIU linear-transition time horizon from 1 to maximum upperbound
$setglobal t_min_miu 9
$setglobal t_max_miu 38

* MIU maximum reacheable upperbound
$setglobal max_miuup 1.2

* Carbon-intensity transition curve
* | linear_pure | linear_soft | sigmoid_HHs | sigmoid_Hs | sigmoid_Ms | sigmoid_Ls | sigmoid_LLs |
$setglobal sig_trns_type 'sigmoid_Ls'

* Time of full-convergence to dice-ref carbon-intensity curve
* | 28 | 38 | 48 | 58 |
$setglobal sig_trns_end  '38'

* SSP-n hypothesis on dice-reference curve for carbon-intensity
* |original | discounted |
$setglobal sig_dice_ref_curve 'discounted'


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SET ere 'Emissions-related entities'/
    co2
    co2ffi # Fossil-fuel and Industry CO2
    nip    # net import of permits
    sav    # saved permits
    kghg   # Kyoto greenhouse gases
    ch4
    n2o
    sf6
    #hfc
    #pfc
/;
ALIAS(ere,eere);

SET map_e(ere,eere) 'Relationships between Sectoral Emissions' /
    co2.co2ffi
/;

SET ghg(ere) 'Green-House Gases'
/
    co2
    ch4
    n2o
    #sf6
    #hfc
    #pfc
/;

SET oghg(ghg) 'Other GHGs'
/
    ch4
    n2o
    #sf6
    #hfc
    #pfc
/;

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

# .......  PARAMETERS HARDCODED OR ASSIGNED  .......
PARAMETERS
* Cumulative emissions startings
   cumeind0   'Starting value of cumulative emissions from industry [GtC]'                 / 400   /  # DICE2016
   cumetree0  'Starting value of cumulative emissions from land use deforestation [GtC]'   / 100   /
* Availability of fossil fuels
   fosslim    'Maximum cumulative extraction fossil fuels (GtC)' / 6000 /
* MIU rate controls
   miu0       'Initial emissions control rate for base calib_emissions'    / 0 / 
   min_miu     'upper bound for control rate MIU at t_min_miu'       / 1.00 / # best compromise
   t_min_miu    'time t when min_miu value can be reached'           / %t_min_miu%    / # 7 - 2045
   max_miu     'upper bound for control rate MIU from t_max_miu'     / %max_miuup%  / # the old DICE limmiu
   t_max_miu    'time t when max_miu value can be reached'           / %t_max_miu%  / # 28 - 2150
   min_miuoghg 'upper bound for control rate MIU at t_min_miu'       / 0.7  / # best compromise
   max_miuoghg 'upper bound for control rate MIU from tmax'        / 1    / # best compromise
;

##  PARAMETERS EVALUATED ----------

SCALAR
* Conversion coefficients
   CtoCO2        'conversion factor from Carbon to CO2'
   CO2toC        'conversion factor from CO2 to Carbon'
;

## BAU EMISSIONS AND CARBON INTENSITY 
PARAMETERS
    ssp_emi_bau(ssp,t,n)   'SSP-Decline rate of decarbonization according to different scenarios (per period)'
    emi_bau_co2(t,n)       "Baseline regional CO2 FFI emissions [GtCO2]"
    sigma(t,n)                  'Carbon intensity of GDP [kgCO2 per USD(2005)]'
    sig0(n)                     'Carbon intensity at starting time [kgCO2 per output 2005 USD]'
;

$gdxin '%datapath%data_baseline_emissions_calibrated.gdx'
$load   ssp_emi_bau=emi_bau_calibrated
$gdxin
* Configuration settings determine imported scenario
emi_bau_co2(t,n) = ssp_emi_bau('%baseline%',t,n)  ;



##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

CtoCO2 = 44 / 12 ;
CO2toC = 12 / 44 ;

* Baseline emissions
sigma(t,n) = emi_bau_co2(t,n)/ykali(t,n) ;
sig0(n)    = sigma('1',n)    ;

* Initial emissions
e0(n) = q0(n) * sig0(n);

$if %baseline%=='ssp5' fosslim=10000;

$if set noneg max_miu=1;

*following challenges to mitigation criterium
$if %residual_emissions%=='low' max_miu=1; 
$if %residual_emissions%=='medium' max_miu=0.975; 
$if %residual_emissions%=='high' max_miu=0.925; 

##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

## EMISSIONS CO2 ----------
VARIABLES

    E(t,n)          'Total CO2 emissions  [GtCO2/year]'
    EIND(t,n)       'Industrial emissions [GtCO2/year]'

    CCAEIND(t)      'Cumulative Industrial Carbon Emissions [GTC]'
    CCAETOT(t)      'Cumulative Carbon Emissions [GTC]'
    CUMETREE(t)     'Cumulative from land [GtC]'

    CCO2EIND(t)     'Cumulative Industrial CO2 Emissions [GtCO2]'
    CCO2ETOT(t)     'Cumulative CO2 Emissions [GtCO2]'

    MIU(t,n)        'Emission control rate GHGs'
    ABATEDEMI(t,n)  'Abated Emissions [GtCO2/year]'
;
POSITIVE VARIABLES  ABATEDEMI, MIU ;

# VARIABLES STARTING LEVELS 
     EIND.l(t,n) = sigma(t,n)*ykali(t,n) ;
        E.l(t,n) = EIND.l(t,n) + eland_bau('uniform',t,n) ;
      MIU.l(t,n) = 0 ; 
ABATEDEMI.l(t,n) = 0 ;

## EMISSIONS OGHG ----------
$ifthen.oghg %climate% == 'witchoghg'
VARIABLES
    EOGHG(oghg,t,n)       'Total OGHG emissions [GtCO2eq/year]'
    COGHGE(oghg,t)        'Cumulative OGHG emissions [GtCO2eq]'
    MIU_OGHG(oghg,t,n)    'Emission control rate GHGs'
    ABATEDOGHG(oghg,t,n)  'Abated OGHG Emissions [GtCO2eq/year]'
;
POSITIVE VARIABLES  ABATEDOGHG, MIU_OGHG;

# VARIABLES STARTING LEVELS 
     EOGHG.l(oghg,t,n) = oghg_emi_bau(oghg,t,n) ;
ABATEDOGHG.l(oghg,t,n) = 0 ;
  MIU_OGHG.l(oghg,t,n) = 0 ;
$endif.oghg

##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

##  EMISSIONS CO2 ----------
* Industrial emissions starting point
EIND.fx(tfirst,n) = e0(n) ;
* Resource limit for fossils emissions
CCAEIND.up(t) = fosslim ;
* Initial cumulated conditions
CCAEIND.FX(tfirst)  = cumeind0    ;
CUMETREE.fx(tfirst) = cumetree0   ;
CCAETOT.FX(tfirst)  = cumeind0 + cumetree0 ;
* CO2-budget starts empty
CCO2EIND.FX(tfirst) = 0 ;
CCO2ETOT.FX(tfirst) = 0 ;

##  OGHG EMISSION VARIABLES ----------
$ifthen.oghg %climate% == 'witchoghg'
* Oghg emissions starting point
EOGHG.FX(oghg,tfirst,n)   =  oghg_emi_bau(oghg,tfirst,n);
* OGHG-budget starts empty
COGHGE.FX(oghg,tfirst)    = 0 ;
$endif.oghg

##  CO2 MITIGATION UPPER BOUND SHAPE ----------
loop(t,
# Before transition
MIU.up(t,n)$(t.val lt t_min_miu) = min_miu;
# Transition to negative: linear transition from min_miu to max_miu between t_min_miu and t_max_miu
MIU.up(t,n)$(t.val ge t_min_miu) = min_miu + (max_miu - min_miu) * (t.val - t_min_miu)/(t_max_miu - t_min_miu);
# After transition
MIU.up(t,n)$(t.val gt t_max_miu) = max_miu;
);

##  OGHG MITIGATION UPPER BOUND SHAPE ----------
$ifthen.oghg %climate% == 'witchoghg'
loop(t,
# before transition
MIU_OGHG.up(oghg,t,n)$(t.val lt t_min_miu) = min_miuoghg;
# transition: linear transition from min_miu to max_miu between t_min_miu and t_max_miu
MIU_OGHG.up(oghg,t,n)$(t.val ge t_min_miu) = min_miuoghg + (max_miuoghg - min_miuoghg) * (t.val - t_min_miu)/(t_max_miu - t_min_miu);
# after transition
MIU_OGHG.up(oghg,t,n)$(t.val gt t_max_miu) = max_miuoghg;
);
MIU_OGHG.fx(oghg,tfirst,n) = 0 ; #setting 2015 value
$endif.oghg


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

##  CO2 EMISSION EQUATIONS ----------
    eq_e                # Emissions equation'
    eq_eind             # Industrial emissions equation'
    eq_ccaeind          # Cumulative carbon emissions equation'
    eq_ccaetot
    eq_cco2eind         # Cumulative CO2 emissions equation (from now on)'
    eq_cco2etot
    eq_cumetree         # Cumulated land-use emissions
    eq_abatedemi        # Abated Emissions according to decision'
#    eq_miuinertiaplus   # Inertia in CO2 Control Rate decreasing'
#    eq_miuinertiaminus  # Inertia in CO2 Control Rate increasing'
##  OGHG EMISSION EQUATIONS ----------
$ifthen.oghg %climate% == 'witchoghg'
    eq_eoghg                 #'OGHG emissions equation'
    eq_coghge                #'Cumulative OGHG emissions equation'
    eq_abatedoghg            #'Abated OGHG Emissions according to MIU decision'
    eq_oghg_miuinertiaplus   #'Inertia in OGHG Control Rate decreasing'
    eq_oghg_miuinertiaminus  #'Inertia in OGHG Control Rate increasing'
$endif.oghg


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

##  EMISSIONS CO2 ----------
* Industrial emissions
 eq_eind(t,n)$(reg(n))..   EIND(t,n)  =E=  sigma(t,n) * YGROSS(t,n) * (1-(MIU(t,n)))  ;

* All emissions
 eq_e(t,n)$(reg(n))..   E(t,n)  =E=  EIND(t,n) + ELAND(t,n) 
$if set mod_dac                      - E_NEG(t,n)
;

* Industrial cumulated emissions in Carbon
 eq_ccaeind(t+1)..   CCAEIND(t+1)  =E=  CCAEIND(t) # All industrial emi per period in Carbon
                                   +  (( sum(n$reg(n), EIND(t,n)) + sum(n$(not reg(n)), EIND.l(t,n)) ) * tstep * CO2toC ) ; #Carbon

* Total cumulated emissions in Carbon
 eq_ccaetot(t+1)..   CCAETOT(t+1)  =E=  CCAETOT(t) # All emi (industrial + land) per period in Carbon
                                   +  (( sum(n$reg(n), E(t,n)) + sum(n$(not reg(n)), E.l(t,n)) ) * tstep * CO2toC )  ; #Carbon

* Land Use cumulated emissions in Carbon
 eq_cumetree(t+1)..   CUMETREE(t+1) =E=  CUMETREE(t) # Land Use emi per period in Carbon
                                    + (( sum(n$reg(n), ELAND(t,n))    + sum(n$(not reg(n)), ELAND.l(t,n)) ) * tstep * CO2toC)  ; #Carbon

* Industrial cumulated emissions in CO2
 eq_cco2eind(t+1)..   CCO2EIND(t+1)   =E=  CCO2EIND(t) # All industrial emi per period
                                      +   (( sum(n$reg(n), EIND(t,n))    + sum(n$(not reg(n)), EIND.l(t,n)) )  * tstep )  ; #CO2

* Total cumulated emissions in CO2
 eq_cco2etot(t+1)..   CCO2ETOT(t+1)   =E=  CCO2ETOT(t) # All emi (industrial + land) per period
                                      +   (( sum(n$reg(n), E(t,n))    + sum(n$(not reg(n)), E.l(t,n)) )    * tstep )  ; #CO2

* Emissions abated
 eq_abatedemi(t,n)$(reg(n))..   ABATEDEMI(t,n)  =E=  MIU(t,n) * sigma(t,n) * YGROSS(t,n)  ;


##  EMISSIONS OGHG ----------
$ifthen.oghg %climate% == 'witchoghg'
* OGHG emissions
eq_eoghg(oghg,t,n)$(reg(n))..   EOGHG(oghg,t,n)  =E=  oghg_emi_bau(oghg,t,n)  * (1-(MIU_OGHG(oghg,t,n))) ;

* OGHG cumulated emissions in CO2eq
eq_coghge(oghg,t+1)..   COGHGE(oghg,t+1)  =E=  COGHGE(oghg,t) # All oghg-emi per period
                                           + (( sum(n$reg(n), EOGHG(oghg,t,n)) + sum(n$(not reg(n)), EOGHG.l(oghg,t,n)) )* tstep) ; #CO2eq
* OGHG Emissions abated
eq_abatedoghg(oghg,t,n)$(reg(n))..   ABATEDOGHG(oghg,t,n)  =E=  MIU_OGHG(oghg,t,n) * oghg_emi_bau(oghg,t,n) ;
$endif.oghg


##  MITIGATION CO2 INERTIA ----------
* Inertia in increasing
#eq_miuinertiaminus(t+1,n)$(map_nt and (t.val gt 1))..   MIU(t+1,n)  =L=  MIU(t,n) + miu_inertia ;

* Inertia in decreasing
#eq_miuinertiaplus(t+1,n)$(map_nt  and (t.val gt 1))..   MIU(t+1,n)  =G=  MIU(t,n) - miu_inertia ;


##  MITIGATION OGHG INERTIA ----------
$ifthen.oghg %climate% == 'witchoghg'
* Inertia in increasing
eq_oghg_miuinertiaminus(oghg,t,n)$(reg(n)  and (t.val gt 1))..   MIU_OGHG(oghg,t,n)  =L=  MIU_OGHG(oghg,t-1,n) + 0.20  ;

* Inertia in decreasing
eq_oghg_miuinertiaplus(oghg,t,n)$(reg(n)  and (t.val gt 1))..   MIU_OGHG(oghg,t,n)  =G=  MIU_OGHG(oghg,t-1,n) - 0.50  ;
$endif.oghg


##  FIX VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='fix_variables'

tfixvar(MIU,'(t,n)')

##  BEFORE SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='before_solve'


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Sets (excl. aliases) ---------------------------------
ghg

# Parameters -------------------------------------------
fosslim
max_miu
t_max_miu
t_min_miu
CtoCO2
CO2toC
sigma
emi_bau_co2

# Variables --------------------------------------------
E
EIND
MIU
ABATEDEMI
CCO2EIND
CCO2ETOT

# Equations -------------------
eq_e

$endif.ph



 modules/core_policy.gms

# POLICY Module
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'


$ifthen.pol '%policy%'=='bau'
* Noncoop is faster but also coop would be ok
$setglobal impact "off"

$elseif.pol '%policy%'=='bau_impact'
* BAU with impacts
*$setglobal impact "burke"

$elseif.pol '%policy%'=='simulation'
* Simulation mode, fixed saving rates and no mitigation, but possibly with impacts
$setglobal savings 'fixed'

$elseif.pol '%policy%'=='simulation_fixed_miu'
* Simulation mode, fixed saving rates and no mitigation, but possibly with impacts
$setglobal savings 'fixed'
$setglobal results_for_fixed_miu results_cba_burke

$elseif.pol '%policy%'=='simulation_tatm_exogen'
* Simulation mode, fixed saving rates and no mitigation, and given TATM temperature trajectory (emissions don't match!)
* define trajectory in mod_climate_tatm_exogen.gms
$setglobal savings 'fixed'

$elseif.pol '%policy%'=='simulation_climate_regional_exogen'
* Simulation mode, fixed saving rates and no mitigation, and given TATM temperature trajectory (emissions don't match!)
* Set to import regions temperatures to RCP for CMIP5 data (26, 45, 60, 85) or scenario for CMIP6 data (ssp126, ssp245, ss370, ssp585)
$if %downscaling%=="cmip5_pop" $setglobal temp_region_exogen 45
$if %downscaling%=="cmip6_pop" $setglobal temp_region_exogen "ssp245"
$if %downscaling%=="cmip6_area" $setglobal temp_region_exogen "ssp245"
$setglobal savings 'fixed'
#$setglobal damages_postprocessed

$elseif.pol '%policy%'=='cbudget'
* CUMULATED CO2 LIMIT from 2019 until 2100 in GtCO2 (as in ENGAGE) TOTAL CO2
$if not %cooperation% == 'coop' $abort 'USER ERROR: cbudget option requires cooperative mode.'
* For noncooperative runs, use policy=cbudget_regional with burden=cost_efficiency
$setglobal cbudget 1150
$setglobal impact "off"

$elseif.pol '%policy%'=='cba'

$elseif.pol '%policy%'=='cea_tatm'
* limit GMT to %tatm_limit% degrees above preindustrial
$setglobal tatm_limit 2
* Enable/disable overshoot option
$setglobal overshoot "yes"
$setglobal damages_postprocessed

$elseif.pol '%policy%'=='cea_rcp'
* limit total radiative forcing to %forc_limit% W/m2
$setglobal forc_limit 4.5
* Enable/disable overshoot option
$setglobal overshoot "yes"
$setglobal damages_postprocessed

$elseif.pol '%policy%'=='ctax'
*by defaults, no impacts
$setglobal impact "off"
*Tax in 2015 in USD/tCO2 (by default increasing by 5% p.a.), constant after 2100
$setglobal ctax_initial 5
*Starting year of the carbon tax
$setglobal ctax_start 2025
$setglobal growth_rate 'uniform'
$setglobal ctax_shape 'exponential'
$setglobal ctax_slope 0.05

*this flag fixes the MAC to equal exaclty the carbon tax (NB this FIXES CPRICE and may cause infeasibilities combined with other policies)
$setglobal ctax_marginal


$elseif.pol '%policy%'=='dice'
*$setglobal cooperation 'coop'
$setglobal climate 'dice2016'
$setglobal impact 'dice'
$setglobal macc 'dice2016'

$elseif.pol '%policy%'=='cbudget_regional'
* run carbon budget (also non cooperatively) with a pre-defined budget sharing formula
$setglobal cbudget 1150
$setglobal impact "off"
* some burden sharing formulas may not solve for low budgets: equal_per_capita, historical_responsability, grandfathering, cost_efficiency
$setglobal burden "cost_efficiency"

$ifthen.bgr %burden%=='cost_efficiency'
* Tolerance error for budget (in GtCO2) for noncooperative budgets
$setglobal conv_budget 1
*this flag fixes the MAC to equal exaclty the carbon tax  (NB this FIXES CPRICE and may cause infeasibilities combined with other policies)
$setglobal ctax_marginal
$setglobal ctax_start 2025
$setglobal growth_rate 'uniform'
$setglobal ctax_shape 'exponential'
$setglobal ctax_slope 0.05

$endif.bgr

$else.pol
$abort 'Please specify a valid policy via --policy=='
$endif.pol

* NDCs type: | cond | uncond |
* Conditional or unconditional (less stringent) Nationally Determined Contributions (NDCs
$setglobal ndcs_type "cond"

## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

#verify conf phase set all flags correctly
$ifthen.pol '%policy%'=='bau'
$if not %impact%=="off" $abort 'USER ERROR: impact=off must be used for BAU policy!'
$elseif.pol '%policy%'=='simulation'
$if not %savings%=="fixed" $abort 'USER ERROR: no_mitigation simulation mode requires fixedconf savings!'
*$if not %cooperation%=="noncoop" $abort 'USER ERROR: noncooperation required with any < simulation >  policy!'
$elseif.pol '%policy%'=='simulation_tatm_exogen'
$if not %savings%=="fixed" $abort 'USER ERROR: no_mitigation simulation mode requires fixedconf savings!'
$if not %cooperation%=="noncoop" $abort 'USER ERROR: noncooperation required with any < simulation >  policy!'
$elseif.pol '%policy%'=='simulation_climate_regional_exogen'
$if not %savings%=="fixed" $abort 'USER ERROR: no_mitigation simulation mode requires fixedconf savings!'
$if not %cooperation%=="noncoop" $abort 'USER ERROR: noncooperation required with any < simulation >  policy!'
$elseif.pol '%policy%'=='cbudget'
*$if not %impact%=="off" $abort 'USER ERROR: impact=off possibly intended for using a cbudget? Else comment in core_policy.gms.'
$elseif.pol '%policy%'=='cea_tatm'
$if not %cooperation%=="coop" $abort 'USER ERROR: cooperation required with < cea_tatm >  policy!'
$elseif.pol '%policy%'=='cea_rcp'
$if not %cooperation%=="coop" $abort 'USER ERROR: cooperation required with < cea_rcp >  policy!'
$elseif.pol '%policy%'=='ctax'
$elseif.pol '%policy%'=='cbudget_regional'
$elseif.pol '%policy%'=='dice'
$if %cooperation% == 'coop' $if not %swf% == 'dice' $abort 'USER ERROR: $setglobal swf dice for DICE replication'
$if %cooperation% == 'coop' $if not %region_weights% == 'negishi' $abort 'USER ERROR: $setglobal region_weights negishi for DICE replication'
$endif.pol
$if set ctax_marginal $if not %macc%=='ed' $abort "fixed ctax requires MACC ed curves to run"
$if set pol_ndc $if not %macc%=='ed' $abort "ndc extrapolation requires MACC ed curves to run"

set years_budget(t);
years_budget(t)$(year(t) ge 2100) = yes; 
$if %overshoot%=="no" years_budget(t)$(year(t) gt 2020) = yes; 

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

Parameter ctax(t,n);
ctax(t,n) = 0;

Parameter ctax_corrected(t,n);
ctax_corrected(t,n) = 0;

#load MIUs for NDCs to fix policy levels before 2020
Parameter miu_ndcs_2030(n) "Mitigation levels in 2030 according to countries NDCs";
$gdxin  '%datapath%data_pol_ndc.gdx'
$load    miu_ndcs_2030 = pbl_%ndcs_type%_2030
$gdxin
Parameter miu_fixed_levels(t,n) "Mitigation levels fixed to meet 2030 %ndcs_type% NDCs";
miu_fixed_levels('1',n) = miu0;
miu_fixed_levels('4',n) = miu_ndcs_2030(n);
# intermediate values
miu_fixed_levels('2',n) = miu_fixed_levels('1',n) + ((1/3) * (miu_fixed_levels('4',n) - miu_fixed_levels('1',n))) ;
miu_fixed_levels('3',n) = miu_fixed_levels('1',n) + ((2/3) * (miu_fixed_levels('4',n) - miu_fixed_levels('1',n))) ;

Scalar cbudget_2020_2100 /0/;

$ifthen.pol '%policy%'=='simulation_fixed_miu'
Variable MIU_loaded(t,n);
$gdxin %results_for_fixed_miu%
$loaddc MIU_loaded=MIU
$gdxin

$elseif.pol '%policy%'=='ctax'

scalar ctax_var;
ctax_var = %ctax_initial%;

$elseif.pol '%policy%'=='cbudget_regional'
$ifthen.bgr  %burden%=="cost_efficiency"

scalar ctax_var;
scalar ctax_target_rhs /%cbudget%/;
ctax_var = max(581.12 -74.3*log(%cbudget%),1);

$endif.bgr

parameter burden_share(n), carbon_carbon_debt(n);

$endif.pol

##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

#burden sharing formulas follow https://link.springer.com/article/10.1007/s10584-019-02368-y#Sec2 

$ifthen.share %burden%=="equal_per_capita"

burden_share(n) = sum(t$(year(t) le 2100),pop(t,n))/sum((t,nn)$(year(t) le 2100),pop(t,nn));

$elseif.share %burden%=="historical_responsability"

parameter l_valid_wdi(yearlu,n);
$gdxin 'data_%n%/data_historical_values'
$load l_valid_wdi
$gdxin

carbon_carbon_debt(n) = sum(yearlu$(yearlu.val ge 1960 and yearlu.val le 2010), (l_valid_wdi(yearlu,n) * sum(nn,q_emi_valid_primap('co2ffi',yearlu,nn)/l_valid_wdi(yearlu,nn)) -  q_emi_valid_primap('co2ffi',yearlu,n) ) );
burden_share(n) = (sum(t$(year(t) le 2100),pop(t,n))/sum((t,nn)$(year(t) le 2100),pop(t,nn)) + carbon_carbon_debt(n)/ sum(nn,carbon_carbon_debt(nn)) ) / 2 ;

$elseif.share %burden%=="grandfathering"

burden_share(n) = e0(n)/sum(nn,e0(nn));

$elseif.share %burden%=="cost_efficiency"

* very large number, make eq_carbon_budget_reg useless
burden_share(n) = 1e4; 

$else.share 
$if %policy%=="cbudget_regional" $abort "USER ERROR: please choose a valid effort sharing formula!"
$endif.share 

$ifthen.pol '%policy%'=='ctax'

* compute full tax schedule
ctax(t,n) = 1e-8;
ctax(t,n)$(year(t) eq %ctax_start%) = max(ctax_var/1000,1e-8);

$ifthen.grt %growth_rate%=="uniform"

$ifthen.ctx %ctax_shape%=="constant"
ctax(t,n)$(year(t) gt %ctax_start%) =   ctax_var/1000; #convert from USD/tCO2 to T$/GtCO2
$elseif.ctx %ctax_shape%=="linear"
ctax(t,n)$(year(t) gt %ctax_start%) =  ctax_var/1000 * (1 + %ctax_slope%) * (year(t)-%ctax_start%); #convert from USD/tCO2 to T$/GtCO2
$elseif.ctx %ctax_shape%=="exponential"
ctax(t,n)$(year(t) gt %ctax_start%) =   ctax_var/1000 * (1 + %ctax_slope%)**(year(t)-%ctax_start%); #convert from USD/tCO2 to T$/GtCO2
$endif.ctx

$elseif.grt %growth_rate%=="hotelling"
ctax(t,n)$(year(t) gt %ctax_start%) = (ctax_var/1000) * (1 + sum(nn,RI.l(t,nn)*pop(t,nn)/sum(nnn,pop(t,nnn))))**(year(t)-%ctax_start%);
$elseif.grt %growth_rate%=="diff"
ctax(t,n)$(year(t) eq %ctax_start%) = max(ctax_var/1000,1e-8);
ctax(t,n)$(year(t) gt %ctax_start%) = (ctax_var/1000) * (1 + RI.l(t,n))**(year(t)-%ctax_start%);
$endif.grt

ctax(t,n)$(year(t) gt 2100) = ctax('18',n);

$endif.pol

##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'



##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

MIU.fx(t,n)$(year(t) le 2020) = miu_fixed_levels(t,n);

$if '%policy%'=='bau' MIU.l(t,n) = 0; MIU.fx(t,n) = 0; 

$if '%policy%'=='bau_impact' MIU.l(t,n) = 0; MIU.fx(t,n) = 0;

$if '%policy%'=='simulation' MIU.l(t,n) = 0; MIU.fx(t,n) = 0;

$if '%policy%'=='simulation_fixed_miu' MIU.l(t,n) = MIU_loaded.l(t,n); MIU.fx(t,n) = MIU_loaded.l(t,n);

$if '%policy%'=='simulation_tatm_exogen' MIU.l(t,n) = 0; MIU.fx(t,n) = 0;

$if '%policy%'=='simulation_climate_regional_exogen' MIU.l(t,n) = 0; MIU.fx(t,n) = 0;

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================
##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

$if '%policy%'=='cea_rcp' eq_forc_limit
$if '%policy%'=='cea_tatm' eq_tatm_limit
$if '%policy%'=='cbudget' eq_carbon_budget
$if '%policy%'=='cbudget_regional' eq_carbon_budget_reg
$if set ctax_marginal eq_ctax

##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

$ifthen.cb '%policy%'=='cbudget'


eq_carbon_budget(tt)$years_budget(tt).. 
                        sum((t,n)$(year(t) gt 2020 and year(t) lt (tt.val*5 + 2010) ), E(t,n)) * tstep 
                        + 3.5 * sum(n,E('2',n)) # 2020-2022.5
                        + 2.5 * sum(n,E(tt,n)) # final year
                        =L=  %cbudget%; 

$endif.cb

$ifthen.cbr '%policy%'=='cbudget_regional' 

eq_carbon_budget_reg(n,tt)$(reg(n) and years_budget(tt)).. 
                        sum(t$(year(t) gt 2020 and year(t) lt (tt.val*5 + 2010) ), E(t,n) - ELAND(t,n)) * tstep
                        + 3.5 * (E('2',n) - ELAND('2',n)) # 2020-2022.5
                        + 2.5 * (E(tt,n) - ELAND(tt,n)) # final year
                        =L=  ( %cbudget% - 
                        sum((t,nn)$(year(t) gt 2020 and year(t) lt (tt.val*5 + 2010) ), ELAND(t,nn)) * tstep 
                        - ( sum(nn,3.5 * (ELAND('2',n)) + 2.5 * (ELAND(tt,n)) ) ) ) * burden_share(n); 

$endif.cbr

$ifthen.cea '%policy%'=='cea_tatm'
$ifthen.over %overshoot%=="yes"
* limit GMT only from 2100 an beyond
 eq_tatm_limit(t)$(year(t) ge 2100)..   TATM(t)  =L=  %tatm_limit% ;
$else.over
* No overshoot, always below limit
 eq_tatm_limit(t)..   TATM(t)  =L=  %tatm_limit% ;
$endif.over
$endif.cea

$ifthen.cea '%policy%'=='cea_rcp'
$ifthen.over %overshoot%=="yes"
* limit FORC only from 2100 an beyond
 eq_forc_limit(t)$(year(t) ge 2100)..   FORC(t)  =L=  %forc_limit% ;
$else.over
* No overshoot, always below limit
 eq_forc_limit(t)..   FORC(t)  =L=  %forc_limit% ;
$endif.over
$endif.cea

$ifthen.ctx set ctax_marginal
eq_ctax(t,n)$(year(t) ge %ctax_start% and reg(n)).. CPRICE(t,n) =E= ctax_corrected(t,n);
$endif.ctx

##  FIX VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='fix_variables'

##  BEFORE SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='before_solve'

* CO2 carbon budget 2020-2100
cbudget_2020_2100  =  sum((t,n)$(year(t) gt 2020 and year(t) le 2095), E.l(t,n)) * tstep
                + 3.5 * sum(n,E.l('2',n)) # 2020-2022.5
                + 2.5 * sum(n,E.l('18',n)) # 2100
;

$ifthen.pol '%policy%'=='cbudget_regional'
$ifthen.bgr %burden%=="cost_efficiency"

if((ord(iter) gt 1) and (ctax_target_rhs>0) and abs(cbudget_2020_2100-ctax_target_rhs) gt %conv_budget%,
    ctax_var = ctax_var * ( min((6000 - ctax_target_rhs) / max((6000 - cbudget_2020_2100), 1), 3) )**2.2 );

abort$(ctax_var>10000) 'Stop because ctax is too high';

abort$(ctax_var<1e-8) 'Budget is higher than bau emissions';


* compute full tax schedule
ctax(t,n) = 1e-8;
ctax(t,n)$(year(t) eq %ctax_start%) = max(ctax_var/1000,1e-8);

$ifthen.grt %growth_rate%=="uniform"

$ifthen.ctx %ctax_shape%=="constant"
ctax(t,n)$(year(t) gt %ctax_start%) =   ctax_var/1000; #convert from USD/tCO2 to T$/GtCO2
$elseif.ctx %ctax_shape%=="linear"
ctax(t,n)$(year(t) gt %ctax_start%) =  ctax_var/1000 * (1 + %ctax_slope%) * (year(t)-%ctax_start%); #convert from USD/tCO2 to T$/GtCO2
$elseif.ctx %ctax_shape%=="exponential"
ctax(t,n)$(year(t) gt %ctax_start%) =   ctax_var/1000 * (1 + %ctax_slope%)**(year(t)-%ctax_start%); #convert from USD/tCO2 to T$/GtCO2
$endif.ctx

$elseif.grt %growth_rate%=="hotelling"
ctax(t,n)$(year(t) gt %ctax_start%) = (ctax_var/1000) * (1 + sum(nn,RI.l(t,nn)*pop(t,nn)/sum(nnn,pop(t,nnn))))**(year(t)-%ctax_start%);
$elseif.grt %growth_rate%=="diff"
ctax(t,n)$(year(t) eq %ctax_start%) = max(ctax_var/1000,1e-8);
ctax(t,n)$(year(t) gt %ctax_start%) = (ctax_var/1000) * (1 + RI.l(t,n))**(year(t)-%ctax_start%);
$endif.grt

ctax(t,n)$(year(t) gt 2100) = ctax('18',n);

$endif.bgr
$endif.pol

$ifthen.dctx set differentiated_ctax
*from world bank classification https://blogs.worldbank.org/opendata/new-world-bank-country-classifications-income-level-2022-2023 
ctax(t,n)$(year(t) ge %ctax_start% and ord(t) le 10 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) gt 0 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) le 4125) = ctax(t,n) * (0.25*(2050-year(t))/(2050-%ctax_start%) + 0.5*(year(t)-%ctax_start%)/(2050-%ctax_start%)); 
ctax(t,n)$(year(t) ge %ctax_start% and ord(t) gt 10 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) gt 0 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) le 4125) = 0.5*ctax(t,n); 
ctax(t,n)$(year(t) ge %ctax_start% and ord(t) le 10 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) gt 4125 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) le 13205) = ctax(t,n) * (0.5*(2050-year(t))/(2050-%ctax_start%) + 0.75*(year(t)-%ctax_start%)/(2050-%ctax_start%)); 
ctax(t,n)$(year(t) ge %ctax_start% and ord(t) gt 10 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) gt 4125 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) le 13205) = 0.75*ctax(t,n); 
ctax(t,n)$(year(t) ge %ctax_start% and ord(t) le 10 and (ykali('2',n)/pop('2',n)*1e6*113.647/104.691) gt 13205) = ctax(t,n); 
$endif.dctx 

$ifthen.rctx set smooth_ctax
* ramp-up before reaching the exponential
ctax(t,n)$(year(t) eq (%ctax_start% + 0)) = ctax(t,n) * (1-(0.5));
ctax(t,n)$(year(t) eq (%ctax_start% + 1*tstep)) = ctax(t,n) * (1-(0.5*0.5));
ctax(t,n)$(year(t) eq (%ctax_start% + 2*tstep)) = ctax(t,n) * (1-(0.5*0.5*0.5));
ctax(t,n)$(year(t) eq (%ctax_start% + 3*tstep)) = ctax(t,n) * (1-(0.5*0.5*0.5*0.5));
$endif.rctx 

ctax_corrected(t,n) = min( ctax(t,n)*1e3, mx(t,n)* ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU.up(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU.up(t,n),4))) );


##  AFTER SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='after_solve'

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================
##  REPORT
#_________________________________________________________________________
$elseif.ph %phase%=='report'

$if '%policy%'=='simulation_climate_regional_exogen' TATM.l(t) = NA; #since TATM not correct in this case

* CO2 carbon budget 2019-2100
cbudget_2020_2100  =  sum((t,n)$(year(t) gt 2020 and year(t) le 2095), E.l(t,n)) * tstep
                + 3.5 * sum(n,E.l('2',n)) # 2020-2022.5
                + 2.5 * sum(n,E.l('18',n)) # 2100
;

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

ctax
ctax_corrected
cbudget_2020_2100
$if '%policy%'=='cbudget'  eq_carbon_budget
$if '%policy%'=='cea_rcp'  eq_forc_limit
$if '%policy%'=='cbudget_regional' burden_share carbon_carbon_debt
$endif.ph



 modules/core_regions.gms


* MODULE REGIONS
*
* Contains all starting data and main dynamics for model regions
*
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

$include %datapath%regions.conf


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SET n 'Regions' /
$include %datapath%n.inc
/;

$include %datapath%regions.inc

set   reg(n)     'Active regions to be solved' ;
alias(n,nn,nnn,nnnn);

* Subset regulating how many countries to solve
set nsolve(n)   'Which regions must be solved across n set';
$if set only_solve nsolve(n) = yes$(sameas(n,'%only_solve%'));
$if not set only_solve nsolve(n) = yes;

* no limits for the moment
reg(n) = yes;

* Baseline experiments dimensions
SETS
    dice_curve "altenative reference curves"       / original, discounted /
    trns_type  "transition type towards DICE"      /    linear_pure,
                                                        linear_soft,
                                                        sigmoid_HHs,
                                                        sigmoid_Hs,
                                                        sigmoid_Ms,
                                                        sigmoid_Ls,
                                                        sigmoid_LLs  /
    trns_end  "year of convergence to DICE"        / 28, 38, 48, 58 /
;


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'
n


$endif.ph





 modules/core_time.gms

* CORE TIME
*
* Module to state
*  - Temporal structure
*  - Fixed time periods
*  - States of the world 
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

$setglobal tfix 1

## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SETS
    t                 'Time period nodes'  # values in time.inc included below
* Time control
    tfirst(t)         'First time period nodes'
    tsecond(t)        'Second time period node'
    tlast(t)          'Last time period nodes'
    last10(t)         'Last 10 period nodes'
;
alias(t,tt,ttt,tp1,tp2,tm1,tm2);

SET       pre(t,tp1)  'Precedence set, t is the predecessor of tp1'    ;
SET       preds(t,tt) 'Predecessors set, tt are all predecessors of t' ;
PARAMETER tperiod(t)  'Time period'                                    ;
PARAMETER year(t)     'Reference year for period t'                    ;
PARAMETER begyear(t)  'Beginning year for period t'                    ;
PARAMETER tlen(t)     'Length of time period [years]'                  ;
SCALAR    tstep       'Length of each time step [years]'       / 5 /   ;

$include %datapath%/time.inc


* Timecontrol definitions
tfirst(t)  =  yes$(t.val eq 1)          ;
tsecond(t) =  yes$(t.val eq 2)          ;
tlast(t)   =  yes$(t.val eq card(t))    ; #true if it equals t-set size (cardinality)
last10(t)  =  yes$(t.val gt card(t)-10) ;

* Fixed period nodes
set tfix(t)    'fixed period nodes';
tfix(t) = no;

* Create and load fix variable
$macro loadfix(name,idx,type) \
&type FIX&name&&idx; \
execute_load '%gdxfix%.gdx',FIX&name=&name;

* Fix variable in tfix
* ( up to card(tfix) timestep )
$macro tfixvar(name,idx) \
loadfix(name,idx,variable) \
&name.fx&&idx$tfix(t) = FIX&name.l&&idx; \
&name.l&&idx$tfix(t) = FIX&name.l&&idx;

* Fix Variable in tfix+1
* ( up to card(tfix)-1 timestep )
* ( up to card(tfix) timestep )
$macro tfix1var(name,idx) \
loadfix(name,idx,variable) \
loop((t,tfix(tp1))$pre(t,tp1), \
&name.fx&&idx = FIX&name.l&&idx; \
&name.l&&idx = FIX&name.l&&idx; \
);

* load parameter in tfix
$macro tfixpar(name,idx) \
loadfix(name,idx,parameter) \
&name&&idx$tfix(t) = FIX&name&&idx;

* combinations of fixes and regions
$macro map_nt (reg(n) and (not tfix(t)))
$macro map_nt1 (reg(n) and (not tfix(t+1)))
$macro map_t (not tfix(t))


##  FIX VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='fix_variables'

$if set gdxfix $if not set tfix $abort 'gdxfix requires tfix'
$if set gdxfix loop(t, tfix(t) = yes$(tperiod(t) le %tfix%));


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Sets (excl. aliases) ---------------------------------
t
tstep
tfix
tlen

# Parameters -------------------------------------------
year


$endif.ph



 modules/core_welfare.gms

* MODULE WELFARE
*
* Welfare and utility function definitions
*____________
* REFERENCES
* Berger, Loic, and Johannes Emmerling (2020): Welfare as Equity Equivalents, Journal of Economic Surveys 34, no. 4 (26 August 2020): 727-752. https://doi.org/10.1111/joes.12368.
*
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

##  SETTING CONF ---------------------------------------
# These can be changed by the user to explore alternative scenarios

# Social Welfare Function:  dice | disentangled
$setglobal swf 'disentangled'

* Time Discount Rate (rho) of the Ramsey equation
* [0.001, 0.03] with default 0.015 in DICE2016
$setglobal prstp 0.015

* Elasticity of marginal utility of consumption in the Ramsey equation
* with default 1.45 in DICE2016
$setglobal elasmu 1.45

* Inequality aversion
* Range: [0,1.5]; good options: | 0 | 0.5 | 1.45 | 2 |
$setglobal gamma 0.5

# WELFARE GDP-ADJUSTMENT
* | PPP | MER |
$setglobal gdpadjust 'PPP'

# UTILITY SCALING COEFFICIENTS
* these are unnecessary for the calculations but help optimizer covergence.
$setglobal dice_scale1   1e-4   #DICE2013: 0.016408662    #DICE2016: 0.0302455265681763
$setglobal dice_scale2   0      #DICE2013: -3855.106895   #DICE2016: -10993.704

## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

$if %swf%=='disentangled' $if %region_weights%=='negishi' $abort 'Negishi weightes require dice welfare function (--swf=dice)'


## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
* Preferences
    elasmu          'Elasticity of marginal utility of consumption'   /  %elasmu%  / # DICE16 1.45 (alpha)
    prstp           'Initial rate of social time preference per year' /  %prstp%   / # DICE16 .015 (ro-discount rate)
;


* Scaling options to help convergence
PARAMETERS
   dice_scale1  'Scaling factor'    / %dice_scale1% /
   dice_scale2  'Scaling factor'    / %dice_scale2% /

   gamma  'Inequality aversion' / %gamma% /
;

PARAMETERS
   nweights(t,n)         'Weights used in the welfare of the cooperative solution'
   rr(t)                 'Average utility Social Discount rate'
;

PARAMETERS
   welfare_bge(n)
   welfare_regional(n)
;

##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

# WEIGHTS ----------------------------------------------
* Initialized at 1,
* they change in the 'solve_region' file AFTER FIRST ITERATION
nweights(t,n) = 1;

* Discount factor
 rr(t)  =  1 / ( (1+prstp)**(tstep*(t.val-1)) );


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
   PERIODU(t,n)      'One period utility function'
   CEMUTOTPER(t,n)   'Period utility'
   TUTILITY(t)       'Intra-region utility'
   UTILITY           'Welfare function'
   UTARG(t,n)        'Argument of the utility function'
;


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

TUTILITY.lo(t) = 1e-3 ; # needed because of eq_utility (disentangled)


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

eq_utility_arg       # Argument fo the instantanteous utility function
eq_util              # Objective function
$ifthen.wf '%swf%'=='dice'
   eq_cemutotper     # Period utility
   eq_periodu        # Instantaneous utility function equation           
$endif.wf


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

$if not set alternative_utility eq_utility_arg(t,n)$(reg(n)).. UTARG(t,n) =E= CPC(t,n);

* Disentangled welfare function (within coalitions, using inequality aversion basd on gamma)
$ifthen.wf '%swf%'=='disentangled' #(DEFAULT)
eq_util.. UTILITY  =E=  sum(t, ( ( ( (sum(n$reg(n),  pop(t,n)/sum(nn$reg(nn),pop(t,nn))*((UTARG(t,n))**(1-gamma))))**((1-elasmu)/(1-gamma))) / (1-elasmu) ) - 1 )  * rr(t) );

$else.wf '%swf%'=='dice'
* Original DICE welfare function adapted to multiregion
eq_cemutotper(t,n)$(reg(n))..  CEMUTOTPER(t,n)  =E=  PERIODU(t,n) * rr(t) * pop(t,n)  ;

eq_periodu(t,n)$(reg(n))..  PERIODU(t,n)  =E=  ( (UTARG(t,n))**(1-elasmu) - 1)/(1-elasmu) - 1  ;

eq_util..   UTILITY   =E=  (dice_scale1 * tstep * sum((t,n)$map_nt, nweights(t,n)*CEMUTOTPER(t,n) )) + dice_scale2  ;
$endif.wf

##  AFTER SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='after_solve'

#reporting some welfare measures (for regions, abstracting from inequality aversion)
welfare_regional(n) = (sum(t, ( ( pop(t,n) * (UTARG.l(t,n)**(1-elasmu)) / (1-elasmu) ) )  * rr(t) ));
welfare_bge(n) = ( welfare_regional(n) / (sum(t, ( ( pop(t,n) / (1-elasmu) ) )  * rr(t) )) )**(1/(1-elasmu));

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
nweights
welfare_bge
welfare_regional

# Variables --------------------------------------------
UTILITY
UTARG

$endif.ph



 modules/hub_climate.gms

* CLIMATE MODULE
*
* This module gathers all main climate parameters, variables and sets.
* Those will be mapped with specific climate submodules varibles.

#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module 
$ifthen.ph %phase%=='conf'


##  SETTING CONF ---------------------------------------

* CLIMATE MODULE
* | DICE2016 | cbsimple | witchco2 | witchoghg |
$setglobal climate 'witchco2'
$if %policy%==simulation_tatm_exogen $setglobal climate 'tatm_exogen'
$if %policy%==simulation_climate_regional_exogen $setglobal climate 'tatm_exogen'

##  CALIBRATED CONF ------------------------------------
# These settings shouldn't be changed

* Default options
$setglobal default_climate 'witchco2'


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'


## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

##  PARAMETERS HARDCODED OR ASSIGNED ------------------- 
PARAMETERS
    tatm0    'Initial Atmospheric Temperature change [degree C from 1900]'   / 1.12 / #from WITCH bau
   tocean0  'Initial Lower Stratum Temperature change [degree C from 1900]' / 0.109427/ #from WITCH bau
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
   FORC(t)     'Increase in Radiative Forcing [W/m2 from 1900]'
   TATM(t)     'Increase Temperature of Atmosphere [degrees C from 1900]'
   TOCEAN(t)   'Increase Temperature of Lower Oceans [degrees C from 1900]'
;

# VARIABLES STARTING LEVELS 
  TATM.l(t) = tatm0   ; 
TOCEAN.l(t) = tocean0 ; 


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

TATM.UP(t)         =  40     ;
TATM.LO(t)         = -10     ;
TATM.fx(tfirst)    = tatm0   ;

TOCEAN.UP(t)       =  20     ;
TOCEAN.LO(t)       = -1      ;
TOCEAN.FX(tfirst)  = tocean0 ;


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

   eq_forc         # Radiative Forcing equation
   eq_tatm         # Temperature-climate equation for Atmosphere
   eq_tocean       # Temperature-climate equation for Lower Oceans


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
tatm0
tocean0

# Variables --------------------------------------------
FORC
TATM
TOCEAN


$endif.ph



#===============================================================================
*     /////////////////    SUBMODULE SELECTION   ////////////////////
#===============================================================================

* Include the climate full logic (selected as global option)
* Alternatives: | DICE2016 | cbsimple | witchco2 | witchoghg |
$batinclude 'modules/mod_climate_%climate%'  %1



 modules/hub_impact.gms

# IMPACT MODULE
* This module gathers all main impact parameters, variables and sets.
* Those will be mapped with specific impact submodules varibles.
*
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

# DAMAGE CAP
* GDP baseline multiplier (i.e., max_gain=2 -> maximum gains are 2x GDPbase)
*$setglobal damage_cap
$setglobal max_gain    1
$setglobal max_damage  0.9

* for threshold/catastrophic damage
*$setglobal threshold_damage
$setglobal threshold_d 0.20  # (% of GDP)
$setglobal threshold_temp 3.0
$setglobal threshold_sigma 0.05

* gradient damage from fast temperature changes (based on Lempert et al 2000)
*$setglobal gradient_damage
$setglobal gradient_d 0.01 # (% of GDP)

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'



##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
    OMEGA(t,n)               'Economic impact from the impact function from Climate Change [% of GDP]'
    DAMAGES(t,n)             'Damages [Trill 2005 USD / year] (negative values are gains)'
    DAMFRAC(t,n)             'Damages as GDP Gross fraction [%GDPgross]: (negative values are gains)'
    DAMFRAC_UNBOUNDED(t,n)   'Potential unbounded damages, as % of gross GDP (negative values are gains)'
    DAMFRAC_UPBOUND(t,n)        'Potential GDP, net of damages, bounded in maximum gains [Trill 2005 USD / year]'
;

# VARIABLES STARTING LEVELS ----------------------------
OMEGA.l(t,n) = 0 ;
DAMAGES.l(t,n) = 0 ;
DAMFRAC.l(t,n) = 0 ;
DAMFRAC_UPBOUND.l(t,n) = 0  ;

##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

* Tolerance for min/max nlp smooting
SCALAR   delta  /1e-2/ ; #-14 more than 1e-8 get solver stucked

##  STABILITY CONSTRAINTS ------------------------------
* to avoid errors/help the solver to converge
$ifthen.omg %omega_eq% == 'full'
OMEGA.lo(t,n) = (-1 + 1e-5) ; # needed because of eq_komega
$endif.omg

DAMFRAC.lo(t,n) = - %max_gain% - delta;
DAMFRAC.up(t,n) = %max_damage% + delta;

##  CONTROL RATE LIMITS --------------------------------
OMEGA.fx(tfirst,n)  = 0 ;

$if %impact%=="off" OMEGA.fx(t,n) = 0;

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'
    eq_damages        # Damages equation
    eq_damfrac        # Equation for Damages as GDP fraction
    eq_damfrac_nobnd
$if set damage_cap   eq_damfrac_upbnd


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

##  ESTIMATED YNET AND DAMAGES -------------------------
* Unbounded Damfrac
 eq_damfrac_nobnd(t,n)$(reg(n)).. DAMFRAC_UNBOUNDED(t,n)  =E=   1 - ( 1/(1+ (OMEGA(t,n)
$if set mod_adaptation             / ( 1 + (Q_ADA('ada',t,n)**ces_ada('exp',n))$(OMEGA.l(t,n) gt 0) )
) ) )
$if set threshold_damage              + %threshold_d% * errorf( (TATM(t) - %threshold_temp%)/%threshold_sigma%)
$if set gradient_damage               + (%gradient_d% * power( ( sqrt(sqr((TATM(t+1) - TATM(t))) + sqr(delta)) / 0.35) , 4))$(not tlast(t))
$if set mod_srm $if set damage_geoeng + damage_geoeng_amount(n) * (-geoeng_forcing*W_SRM(t,n) / 3.5)**%impsrm_exponent%
;

$ifthen.dc set damage_cap
* Gains upperbound
 eq_damfrac_upbnd(t,n)$(reg(n))..
   DAMFRAC_UPBOUND(t,n)  =E=  ( DAMFRAC_UNBOUNDED(t,n) + %max_damage% - Sqrt( Sqr(DAMFRAC_UNBOUNDED(t,n) - %max_damage%) + Sqr(delta) )  )/2  ;
* Damages lowerbound and final YNET esteem
 eq_damfrac(t,n)$(reg(n))..
   DAMFRAC(t,n)  =E=  ( DAMFRAC_UPBOUND(t,n) - %max_gain% + Sqrt( Sqr(DAMFRAC_UPBOUND(t,n) + %max_gain%) + Sqr(delta) ) )/2  ;

$else.dc
 
eq_damfrac(t,n)$(reg(n))..    DAMFRAC(t,n)  =E=  DAMFRAC_UNBOUNDED(t,n); 

$endif.dc

* Effective net Damages
 eq_damages(t,n)$(reg(n))..   DAMAGES(t,n)  =E=  YGROSS(t,n) * DAMFRAC(t,n);

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================
##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Variables --------------------------------------------
OMEGA
DAMAGES
DAMFRAC
DAMFRAC_UNBOUNDED

$endif.ph


#===============================================================================
*     /////////////////    SUBMODULE SELECTION   ////////////////////
#===============================================================================

* Include the impact full logic (selected as global option)
* Alternatives: | off | dice | burke | dell | kahn |
$if not %impact%=="off" $batinclude 'modules/mod_impact_%impact%'  %1



 modules/mod_adaptation.gms

*-------------------------------------------------------------------------------
* Long-run Damages from Climate Change
* - Economic impacts
* - Adaptation
*-------------------------------------------------------------------------------

$ifthen.ph %phase%=='conf'

* Define adaptation efficacy
$setglobal adap_efficiency ssp2
$if %baseline%=='ssp1' $setglobal adap_efficiency ssp1_ssp5
$if %baseline%=='ssp3' $setglobal adap_efficiency ssp3
$if %baseline%=='ssp5' $setglobal adap_efficiency ssp1_ssp5

$elseif.ph %phase%=='sets'

set
    iq  'Nodes representing economic values (which have a Q)' /ada, cap, act, gcap/
    g   'Adaptation sectors' /prada, rada, scap/
;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='include_data'

Parameter dk_ada(g) ' depreciation of adapatation aggregates';

$gdxin '%datapath%data_mod_damage'

parameter k_h0(n);
$loaddc k_h0

parameter k_edu0(n);
$loaddc k_edu0

parameter owa(*,n);
$loaddc owa

parameter ces_ada(*,n);
$loaddc ces_ada

$gdxin

* Adaptation efficiency

$if not set adap_efficiency $setglobal adap_efficiency 'ssp2'

$ifthen.ae %adap_efficiency%=='ssp2'
ces_ada('eff',n)      = 1;
$elseif.ae %adap_efficiency%=='ssp1_ssp5'
ces_ada('eff',n)      = 1.25;
$elseif.ae %adap_efficiency%=='ssp3'
ces_ada('eff',n)      = 0.75;
$endif.ae


*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_data'

dk_ada('prada') = 0.1;
dk_ada('rada') = 1;
dk_ada('scap') = 0.03;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='declare_vars'

Variable K_ADA(g,t,n), I_ADA(g,t,n), Q_ADA(iq,t,n);
Q_ADA.lo(iq,t,n) = 1e-8;
Q_ADA.up(iq,t,n) = 1e3;
Q_ADA.l(iq,t,n) = 1e-5;
K_ADA.lo(g,t,n) = 1e-8;
K_ADA.up(g,t,n) = 1e3;
K_ADA.l(g,t,n) = 1e-8;
I_ADA.lo(g,t,n) = 1e-8;
I_ADA.up(g,t,n) = 1e3;
I_ADA.l(g,t,n) = 1e-8;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_vars'


K_ADA.fx('prada',tfirst,n) = 1e-5;
K_ADA.fx('rada',tfirst,n)  = 1e-5;
K_ADA.fx('scap',tfirst,n)  = 1e-5;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='declare_vars'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='eql'

eqq_ada
eqq_act
eqq_cap
eqq_gcap

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='eqs'

eqq_ada(t,n)$reg(n)..
            Q_ADA('ada',t,n)  =e= ces_ada('tfpada',n)*(owa('act',n)*Q_ADA('act',t,n)**ces_ada('ada',n)+ owa('cap',n)*Q_ADA('cap',t,n)**ces_ada('ada',n))**(1/ces_ada('ada',n));

eqq_act(t,n)$reg(n)..
            Q_ADA('act',t,n)  =e= ces_ada('eff',n) *owa('actc',n)*(owa('rada',n)*I_ADA('rada',t,n)**ces_ada('act',n)+ owa('prada',n)*K_ADA('prada',t,n)**ces_ada('act',n))**(1/ces_ada('act',n));

eqq_cap(t,n)$reg(n)..
            Q_ADA('cap',t,n)  =e= (owa('gcap',n)*Q_ADA('gcap',t,n)**ces_ada('cap',n)+ owa('scap',n)*K_ADA('scap',t,n)**ces_ada('cap',n))**(1/ces_ada('cap',n));

eqq_gcap(t,n)$reg(n)..
            Q_ADA('gcap',t,n) =e= ((k_h0(n)+k_edu0(n))/2)*tfp(t,n);

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='report'


$elseif.ph %phase%=='gdx_items'

ces_ada
k_edu0
k_h0
owa
K_ADA
I_ADA
Q_ADA

$endif.ph



 modules/mod_climate_cbsimple.gms

* CLIMATE SIMPLE CLIMATE SUB-MODULE
*
* Climate dynamics extremely simplified by discounting CO2 concentration
*____________
* REFERENCES
* - IPCC: https://unfccc.int/sites/default/files/7_knutti.reto.3sed2.pdf

#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

##  SETTING CONF ---------------------------------------

* Transient Climate Response [0.8, 2.4]
* Regulates TATM responce to GHG concentration
$setglobal tcre 1.6

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
** Climate model parameters
        tcre        'Transient Climate Response [degrees C per TtC]'        / %tcre% / # Range 0.8 - 2.4
        fex0        '2015 forcings of non-CO2 GHG [Wm-2]'                   / 0.5 /    #DICE2013: 0.25    #DICE2016: 0.5
        fex1        '2100 forcings of non-CO2 GHG [Wm-2]'                   / 1.0 /    #DICE2013: 0.70    #DICE2016: 1.0
        t2xco2      'Equilibrium temp impact [C per doubling CO2]'         /3.1 /     #DICE2013: 2.9     #DICE2016: 3.1
        fco22x      'Forcings of equilibrium CO2 doubling (Wm-2)'           /3.6813/   #DICE2013: 3.8     #DICE2016: 3.6813
        c10         'Initial climate equation coefficient for upper level'  /0.098  /
        c1beta      'Regression slope coefficient(SoA~Equil TSC)'           /0.01243/
        c1          'Climate equation coefficient for upper level'          /0.1005/   #DICE2013: 0.098   #DICE2016: 0.1005
        c3          'Transfer coefficient upper to lower stratum'           /0.088 /
        c4          'Transfer coefficient for lower level'                  /0.025 /
        force2015                                                           /2.4634/
        tatm2010                                                            /0.80/                   
        tcorr       'Correction factor for TATM'                            /0.3291984/                                
;

##  PARAMETERS EVALUATED ---------- 
PARAMETERS
  forcoth(t)      'Exogenous forcing from other greenhouse gases'
  fcorr           'Correction factor for Radiative Forcing'  
  force0ev        'Starting forcing level'
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

* OGHG forcing exogenous DICE-like
forcoth(t) = fex0 + (1/17) * (fex1-fex0) * (t.val-1)$(t.val lt 18)  # Linear interpolation from fex0 (t1) to fex1 (t17), 
                  + (fex1-fex0)$(t.val ge 18) ;                     # then (t > 17) level fixed to fex1

*Transient TSC Correction ("Speed of Adjustment Parameter")
c1 =  c10 + c1beta*(t2xco2-2.9);

force0ev =  ((fco22x/t2xco2) * tatm2010) 
         +   ((tatm0 -tatm2010)/c1)
         +   (c3*(tatm2010 - tocean0));

fcorr = 0.6*( force2015 - force0ev);


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

FORC.FX(tfirst) = 2.4634;  # from DICE2016 



#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

# TEMPERATURE 
* Athmosphere
eq_tatm(t+1)..   TATM(t+1)  =E=  CCAETOT(t+1) * tcre / 1000   # Conversion tcre: [degree C / TtC] -> [degree C /GtC]
                             +   0.75 * forcoth(t+1)          # OGHG forcing 
                             -   tcorr  ;                     # Correction factor (empirical by me!)

* Ocean
eq_tocean(t+1)..   TOCEAN(t+1)  =E=  TOCEAN(t) + c4 * (TATM(t)-TOCEAN(t))  ;

# FORCING 
eq_forc(t+1)..   FORC(t+1)  =E=  ( (fco22x/t2xco2) * TATM(t) ) # Inversion of the original DICE2016 
                             +   ( (TATM(t+1)-TATM(t))  / c1 ) # TATM( FORC,... ) equation 
                             +   ( c3 *  (TATM(t)-TOCEAN(t)) ) #
                             +   fcorr                         # Empirical correction factor.
$if set mod_srm + geoeng_forcing*(wsrm(t) + sum(nn$reg(nn), (SRM(t,nn) - SRM.l(t,nn))))
;

##  AFTER SOLVE
$elseif.ph %phase%=='after_solve'

# TEMPERATURE 
TATM.l(t+1)   =  CCAETOT.l(t+1) * tcre / 1000   
              +   0.75 * forcoth(t+1)   
              -   tcorr ;

TOCEAN.l(t+1)  =  TOCEAN.l(t) + c4 * (TATM.l(t)-TOCEAN.l(t)) ;

# FORCING 
FORC.l(t+1)  =  ( (fco22x/t2xco2) * TATM.l(t)   )
             +  ( (TATM.l(t+1)-TATM.l(t))  / c1 )
             +  ( c3 *  (TATM.l(t)-TOCEAN.l(t)) )
             +  fcorr 
$if set mod_srm +geoeng_forcing*sum(n,SRM.l(t,n))
             ;


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
tcre
tcorr
forcoth
fcorr

$endif.ph



 modules/mod_climate_dice2016.gms

* CLIMATE DICE2016 SUB-MODULE
* Climate dynamics as original DICE2016 model.
*____________
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS 
* Initial Conditions
    mat0   'Initial Concentration in atmosphere 2015 [GtC]'         /851  / #DICE2013: 830.4   #DICE2016: 851
    mu0    'Initial Concentration in upper strata 2015 [GtC]'       /460  / #DICE2013: 1527.   #DICE2016: 460
    ml0    'Initial Concentration in lower strata 2015 [GtC]'       /1740 / #DICE2013: 10010.  #DICE2016: 1740
    mateq  'Equilibrium concentration atmosphere [GtC]'             /588  /
    mueq   'Equilibrium concentration in upper strata [GtC]'        /360  / #DICE2013: 1350    #DICE2016: 360
    mleq   'Equilibrium concentration in lower strata [GtC]'        /1720 / #DICE2013: 1720    #DICE2016: 10000
    matpre 'Concentration in Atmosphere at pre-industrial level'    /588.000 / 

* Flow paramaters
    b12      'Carbon cycle transition matrix'                       /.088 / #DICE2013: .088    #DICE2016: .12
    b23      'Carbon cycle transition matrix'                       /0.007/ #DICE2013: 0.00250 #DICE2016: 0.007
       
** Climate model parameters
    t2xco2   'Equilibrium temp impact [degree C per doubling CO2]'  /3.1 /  #DICE2013: 2.9     #DICE2016: 3.1
    fex0     '2015 forcings of non-CO2 GHG [Wm-2]'                  /0.5 /  #DICE2013: 0.25    #DICE2016: 0.5
    fex1     '2100 forcings of non-CO2 GHG [Wm-2]'                  /1.0 /  #DICE2013: 0.70    #DICE2016: 1.0
    fco22x   'Forcings of equilibrium CO2 doubling (Wm-2)'          /3.6813/ #DICE2013: 3.8     #DICE2016: 3.6813
    c10      'Initial climate equation coefficient for upper level' /0.098  /
    c1beta   'Regression slope coefficient(SoA~Equil TSC)'          /0.01243/
    c1       'Climate equation coefficient for upper level'         /0.1005/ #DICE2013: 0.098   #DICE2016: 0.1005
    c3       'Transfer coefficient upper to lower stratum'          /0.088 /
    c4       'Transfer coefficient for lower level'                 /0.025 /
;

##  PARAMETERS EVALUATED -------------------------------
PARAMETERS
** Flow parameters 
   b11        'Carbon cycle transition matrix'
   b21        'Carbon cycle transition matrix'
   b22        'Carbon cycle transition matrix'
   b32        'Carbon cycle transition matrix'
   b33        'Carbon cycle transition matrix'

** OGHG forcing
   forcoth(t) 'Exogenous forcing for other greenhouse gases'
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

* Parameters for long-run consistency of carbon cycle
b11 = 1 - b12  ;
b21 = b12 * mateq / mueq  ;
b22 = 1 - b21 - b23  ;
b32 = b23 * mueq / mleq  ;
b33 = 1 - b32  ;

* OGHG forcing exogenous
forcoth(t) = fex0 + (1/17) * (fex1-fex0) * (t.val-1)$(t.val lt 18)  # Linear interpolation from fex0 (t1) to fex1 (t17), 
                  + (fex1-fex0)$(t.val ge 18)  ;                    # then (t > 17) level fixed to fex1

* Transient TSC Correction ("Speed of Adjustment Parameter")
c1 =  c10 + c1beta*(t2xco2-2.9)  ;

##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase VARS, you can DECLARE new variables for your module. 
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'

NONNEGATIVE VARIABLES
  MAT(t)    'Carbon concentration increase in Atmosphere [GtC from 1750]'
   MU(t)    'Carbon concentration increase in Shallow Oceans [GtC from 1750]'
   ML(t)    'Carbon concentration increase in Lower Oceans [GtC from 1750]'
;

##  COMPUTE VARIABLES
#_________________________________________________________________________

$elseif.ph %phase%=='compute_vars'

MAT.LO(t)   =  10   ;
MU.LO(t)    =  100  ;
ML.LO(t)    =  1000 ; 

MAT.FX(tfirst) = mat0  ;
MU.FX(tfirst)  = mu0   ;
ML.FX(tfirst)  = ml0   ;


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________

$elseif.ph %phase%=='eql'

   eq_mat      # Atmospheric concentration equation
   eq_mu       # Shallow Ocean concentration equation
   eq_ml       # Lower Ocean concentration equation


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

# CARBON CYCLE -----------------------------------------
eq_mat(t+1)..  MAT(t+1)  =E=  MAT(t)*b11 + MU(t)*b21 
                          +  ((sum(n$reg(n), E(t,n)) + sum(n$(not reg(n)), E.l(t,n))) * tstep * CO2toC )  ;# Carbon

eq_mu(t+1)..   MU(t+1)  =E=  MAT(t)*b12 + MU(t)*b22 + ML(t)*b32 ;

eq_ml(t+1)..   ML(t+1)  =E=  MU(t)*b23 + ML(t)*b33  ;

# FORCING ---------------------------------------------
eq_forc(t)..   FORC(t)  =E=  fco22x * ((log((MAT(t)/matpre))/log(2))) + forcoth(t)
$if set mod_srm + geoeng_forcing*(wsrm(t) + sum(nn$reg(nn), (SRM(t,nn) - SRM.l(t,nn))))
;

# TEMPERATURES -----------------------------------------
* Athmosphere
eq_tatm(t+1)..   TATM(t+1)  =E=  TATM(t) + c1 * ( (FORC(t+1)-(fco22x/t2xco2)*TATM(t)) - c3 * (TATM(t)-TOCEAN(t)) ) ;
* Ocean
eq_tocean(t+1)..   TOCEAN(t+1)  =E=  TOCEAN(t) + c4 * (TATM(t)-TOCEAN(t)) ;


##  AFTER SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='after_solve'


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# NOTE:
# In order to propagate climate informations across regions 
# (and make each other aware of resulting setting generated 
# by parallel decisions), simulation climate-module phase 
# is called.
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# CARBON CYCLE -----------------------------------------
MAT.l(t+1)  =  MAT.l(t)*b11 + MU.l(t)*b21 + (sum(n, E.l(t,n)) * tstep * CO2toC ) ; # Carbon

MU.l(t+1)  =  MAT.l(t)*b12 + MU.l(t)*b22 + ML.l(t)*b32 ;

ML.l(t+1)  =  MU.l(t)*b23 + ML.l(t)*b33 ;

# FORCING ----------------------------------------------
FORC.l(t)  =  fco22x * ((log((MAT.l(t)/matpre))/log(2))) + forcoth(t)
$if set mod_srm +geoeng_forcing*sum(n,SRM.l(t,n))
;

# TEMPERATURES -----------------------------------------
* Athmosphere
TATM.l(t)$(not tfirst(t))  =  TATM.l(t-1) + c1 * ((FORC.l(t)-(fco22x/t2xco2)*TATM.l(t-1)) - c3 * (TATM.l(t-1)-TOCEAN.l(t-1)))  ;
* Ocean
TOCEAN.l(t+1)  =  TOCEAN.l(t) + c4 * (TATM.l(t)-TOCEAN.l(t))  ;


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
forcoth


$endif.ph


 modules/mod_climate_regional.gms

* MODULE LOCAL TEMPERATURES
*
* Here's the downscaling logic to evalueate ho local temperatures react to
* athmospheric temperature increase.
*____________
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

# Set to import regions temperatures to RCP (26, 45, 60, 85)
*$setglobal temp_region_exogen 26

# Set to activate Burke's conservative approach (maximum local temperature used
# for damages evaluation equal to maximum observed temperature in past calibration data )
*$setglobal temp_region_cap

$setglobal downscaling cmip6_pop #cmip5_pop, cmip6_pop, cmip6_area

## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

set tincpast /'-8','-7','-6','-5','-4','-3','-2','-1','0',1*58/; 
set tnopast(tincpast) /3*58/;  
set tpast(tincpast);  

tpast(tincpast) = not tnopast(tincpast);

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

##  PARAMETERS HARDCODED OR ASSIGNED -------------------
SCALAR max_temp_region_dam "Maximum temperature observed in regions' past time series [C]" /30/;

Parameter tatm_valid(tincpast) "Historical temperatures for past data, increase relative to 1850-1900 mean";

Parameter temp_valid_yearlu(*,yearlu,n);
$gdxin '%datapath%/data_historical_values.gdx'
$ifthen.cmip %downscaling%=="cmip5_pop" $load temp_valid_yearlu=temp_valid_hadcrut4
$else.cmip $load temp_valid_yearlu=temp_valid_hadcrut5
$endif.cmip
$gdxin 

# Downscaler coefficients
parameter climate_region_coef(*,n)  'Estimated coefficients to link GMT and country-level mean temperatures';
$gdxin '%datapath%data_mod_climate_regional'
$if %downscaling%=="cmip5_pop" $loaddc climate_region_coef=climate_region_coef_cmip5
$if %downscaling%=="cmip6_pop" $loaddc climate_region_coef=climate_region_coef_cmip6_pop
$if %downscaling%=="cmip6_area"  $loaddc climate_region_coef=climate_region_coef_cmip6_area
$gdxin

parameter temp_region_valid(t,n,*);
$gdxin '%datapath%data_mod_climate_regional'
$if %downscaling%=="cmip5_pop" $loaddc temp_region_valid=temp_region_valid_cmip5
$if %downscaling%=="cmip6_pop" $loaddc temp_region_valid = temp_region_valid_pop_cmip6
$if %downscaling%=="cmip6_area" $loaddc temp_region_valid = temp_region_valid_area_cmip6
$gdxin

$ifthen.exo set temp_region_exogen
# Exogen local temperatures (for simulation purposes only).
PARAMETER  temp_region_exogen(t,n) 'Loaded exogeous local temperatures';
temp_region_exogen(t,n) = temp_region_valid(t,n,'%temp_region_exogen%');
temp_region_exogen(t,n)$(t.val gt 18) = temp_region_exogen('18',n);
$endif.exo

##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

#calculate average 5yr temperature from yearly hadcrut4 data
tatm_valid(tincpast)$tpast(tincpast) = sum((n,yearlu)$(yearlu.val> (2015-tstep*(1-tincpast.val))-3 and yearlu.val<(2015-tstep*(1-tincpast.val))+3),temp_valid_yearlu('atm',yearlu,n))/(sum(n,1)*tstep) ;
tatm0=tatm_valid('1');

##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase DECLARE VARS, you can DECLARE new variables for your module.
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'

VARIABLES
    TEMP_REGION(t,n)              'Near surface regional average temperature [deg.C]'
    TEMP_REGION_DAM(t,n)          'Regional pop-weighted average temperature used for damages evaluation [deg.C]'
    TEMP_REGION_DAM_INCPAST(tincpast,n)  'Regional pop-weighted average temperature used for damages evaluation [deg.C] inlcuding the past'
;

##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
* DO NOT put VAR.l here! (use the declare_vars phase)
$elseif.ph %phase%=='compute_vars'

##  STABILITY CONSTRAINTS ------------------------------
* to avoid errors/help the solver to converge
* Tolerance for min/max nlp smooting
SCALAR   delta_tempcap  /1e-4/ ;

#Parameter tatm_valid(tincpast)
#tatm_valid(tincpast) = temp_valid_hardcrut4('')
#compute past temperature (0=2010, -6=1980) values and fix based on same downscaling (hadcrud4 global temp anomaly)
TEMP_REGION_DAM_INCPAST.fx(tincpast,n)$(tpast(tincpast)) = climate_region_coef('alpha_temp',n) + climate_region_coef('beta_temp',n) * tatm_valid(tincpast);
TEMP_REGION.l(tfirst,n) = climate_region_coef('alpha_temp',n) + (climate_region_coef('beta_temp',n)) * TATM.l(tfirst);

#_________________________________________________________________________
$elseif.ph %phase%=='before_solve'

TEMP_REGION.l(t,n) = climate_region_coef('alpha_temp',n) + (climate_region_coef('beta_temp',n)) * TATM.l(t);
$if set temp_region_exogen TEMP_REGION.l(t,n)=temp_region_exogen(t,n);
TEMP_REGION_DAM.l(t,n)  =  min(TEMP_REGION.l(t,n), max_temp_region_dam) ;


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

   eq_temp_region           # Local avg temperature downscaling equation
   eq_temp_region_dam       # Local temperature used for damages evaluation equation
   eq_temp_region_dam_incpast

##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

$ifthen.exogn not set temp_region_exogen
# Endogenous regional temperature downscaler
 eq_temp_region(t,n)$(reg(n))..
    TEMP_REGION(t,n) =E= climate_region_coef('alpha_temp',n) + (climate_region_coef('beta_temp',n)) * TATM(t);
$else.exogn
# Exogenous regional temeperature
 eq_temp_region(t,n)$(reg(n))..
    TEMP_REGION(t,n) =E= temp_region_exogen(t,n)  ;
$endif.exogn


$ifthen.tempcap set temp_region_cap
 eq_temp_region_dam(t,n)$(reg(n))..
    TEMP_REGION_DAM(t,n)  =E=  ( TEMP_REGION(t,n) + max_temp_region_dam
                                  - Sqrt( Sqr(TEMP_REGION(t,n)-max_temp_region_dam) + Sqr(delta_tempcap) )
                               )/2  ;
    # ................................................................................................
    # NOTE:
    # Following Burke et al.(2015) conservative approach, here we cap maximum local temperature used
    # for damages evaluation at 30C level, the maximum observed temperature in past time series upon
    # which economic response has been calibrated.
    #
    # A smooth GAMS approximation for  min(f(x),g(y))  is:
    # >   ( f(x) + g(y) - Sqrt( Sqr( f(x)-g(y) ) + Sqr(delta) ) )/2
    # ................................................................................................
$else.tempcap
# No cap here: damages evaluated to effective local temperatures
  eq_temp_region_dam(t,n)$(reg(n)).. TEMP_REGION_DAM(t,n)  =E=  TEMP_REGION(t,n)  ;
$endif.tempcap

   eq_temp_region_dam_incpast(tincpast,n)$(tnopast(tincpast) and reg(n)).. 
      TEMP_REGION_DAM_INCPAST(tincpast,n) =E= sum(t$sameas(t,tincpast), TEMP_REGION_DAM(t,n));


#____________________________________________________________________________________________
$elseif.ph %phase%=='after_solve'

TEMP_REGION.l(t,n) = climate_region_coef('alpha_temp',n) + (climate_region_coef('beta_temp',n)) * TATM.l(t);

$ifthen.exogn set temp_region_exogen
# Exogenous regional temeperature
TEMP_REGION.l(t,n)  =  temp_region_exogen(t,n)  ;
$endif.exogn

$ifthen.tempcap set temp_region_cap
# ................................................................................................
# Following Burke et al.(2015) conservative approach, here we cap maximum local temperature used
# for damages evaluation at 30C level, the maximum observed temperature in past time series upon
# which economic response has been calibrated.
# ................................................................................................
 TEMP_REGION_DAM.l(t,n)  =  min(TEMP_REGION.l(t,n), max_temp_region_dam) ;
$else.tempcap
# No cap here: damages evaluated to effective local temperatures
 TEMP_REGION_DAM.l(t,n)  =  TEMP_REGION.l(t,n)  ;
$endif.tempcap

TEMP_REGION_DAM_INCPAST.l(tincpast,n)$tnopast(tincpast) = sum(t$sameas(t,tincpast), TEMP_REGION_DAM.l(t,n));

*=========================================================================
*   ///////////////////////     REPORTING     ///////////////////////
*=========================================================================

##  REPORT
#_________________________________________________________________________
$elseif.ph %phase%=='report'

 PARAMETERS
   temp_region_base(n)          'Regional base-temperatures (average 1980-2010) [deg C]'
   deltatemp(t,n)               'Difference between current and base temperatures [deg C]'
;
temp_region_base(n)  =  climate_region_coef('base_temp', n);
deltatemp(t,n)  =  TEMP_REGION_DAM.l(t,n) - temp_region_base(n);

PARAMETER temp_mean_world_weighted(t) 'TEMP_REGION World coming from weighted Forcing coefficients';
temp_mean_world_weighted(t) =  sum(n, pop('1',n) *  climate_region_coef('alpha_temp', n))/sum(n,pop('1',n))
                             + (sum(n, pop('1',n) *  climate_region_coef('beta_temp', n))/sum(n,pop('1',n)) ) * TATM.l(t);


##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
climate_region_coef
deltatemp
tatm_valid
temp_region_valid

# Variables --------------------------------------------
TEMP_REGION
TEMP_REGION_DAM
TEMP_REGION_DAM_INCPAST


$endif.ph



 modules/mod_climate_tatm_exogen.gms

* EXOGEN TATM CLIMATE SUB-MODULE
*
* Athmospheric mean Temperature imposed by external data (ssp-based)
* Climate dynamics follow simple-climate specifications
* Intended for SIMULATION mainly
*____________
* REFERENCES
* - IPCC: https://unfccc.int/sites/default/files/7_knutti.reto.3sed2.pdf

#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

$setglobal tatm_inc_tstep 0.05
#setglobal results_for_fixed_tatm results_ssp2_cba_noncoop.gdx

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

Scalar tatm_inc_tstep 'Exogenous increase per tstep (5yrs)' / %tatm_inc_tstep% /;


PARAMETERS
** Climate model parameters
        fex0        '2015 forcings of non-CO2 GHG [Wm-2]'                   / 0.5 /    #DICE2013: 0.25    #DICE2016: 0.5
        fex1        '2100 forcings of non-CO2 GHG [Wm-2]'                   / 1.0 /    #DICE2013: 0.70    #DICE2016: 1.0
        t2xco2      'Equilibrium temp impact [C per doubling CO2]'         /3.1 /     #DICE2013: 2.9     #DICE2016: 3.1
        fco22x      'Forcings of equilibrium CO2 doubling (Wm-2)'           /3.6813/   #DICE2013: 3.8     #DICE2016: 3.6813
        c10         'Initial climate equation coefficient for upper level'  /0.098  /
        c1beta      'Regression slope coefficient(SoA~Equil TSC)'           /0.01243/
        c1          'Climate equation coefficient for upper level'          /0.1005/   #DICE2013: 0.098   #DICE2016: 0.1005
        c3          'Transfer coefficient upper to lower stratum'           /0.088 /
        c4          'Transfer coefficient for lower level'                  /0.025 /
        force2015                                                           /2.4634/
        tatm2010                                                            /0.80/
        tcorr       'Correction factor for TATM'                            /0.3291984/
;

##  PARAMETERS EVALUATED ----------
PARAMETERS
  forcoth(t)      'Exogenous forcing from other greenhouse gases'
  fcorr           'Correction factor for Radiative Forcing'
  force0ev        'Starting forcing level'
;

##  PARAMETERS LOADED ----------
# EXOGENOUS TATM
PARAMETER
    temp_tatm_exogen(t)   'Atmospheric temperature increase from external data [+C]'
;

$ifthen.exo set results_for_fixed_tatm 
$gdxin %results_for_fixed_tatm%
$loaddc temp_tatm_exogen = TATM.l
$gdxin
$endif.exo
##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

$ifthen.exo not set results_for_fixed_tatm
#for now simplified trajectories for tatm
temp_tatm_exogen(t) = tatm0 + tatm_inc_tstep * (t.val - 1);
$endif.exo

* OGHG forcing exogenous DICE-like
forcoth(t) = fex0 + (1/17) * (fex1-fex0) * (t.val-1)$(t.val lt 18)  # Linear interpolation from fex0 (t1) to fex1 (t17),
                  + (fex1-fex0)$(t.val ge 18) ;                     # then (t > 17) level fixed to fex1

*Transient TSC Correction ("Speed of Adjustment Parameter")
c1 =  c10 + c1beta*(t2xco2-2.9);

force0ev =  ((fco22x/t2xco2) * tatm2010)
         +   ((tatm0 -tatm2010)/c1)
         +   (c3*(tatm2010 - tocean0));

fcorr = 0.6*( force2015 - force0ev);


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

FORC.FX(tfirst) = 2.4634;  # from DICE2016
TATM.lo(tfirst) = -inf;
TATM.up(tfirst) = +inf;

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

# TEMPERATURE
* Athmosphere
eq_tatm(t)..   TATM(t)  =E=  temp_tatm_exogen(t) ;
* Ocean
eq_tocean(t+1)..   TOCEAN(t+1)  =E=  TOCEAN(t) + c4 * (TATM(t)-TOCEAN(t))  ;

# FORCING
eq_forc(t+1)..   FORC(t+1)  =E=  ( (fco22x/t2xco2) * TATM(t) ) # Inversion of the original DICE2016
                             +   ( (TATM(t+1)-TATM(t))  / c1 ) # TATM( FORC,... ) equation
                             +   ( c3 *  (TATM(t)-TOCEAN(t)) ) #
                             +   fcorr   ;                     # Empirical correction factor.


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# parameters
temp_tatm_exogen


$endif.ph



 modules/mod_climate_witchco2.gms

* CLIMATE WITCH-CO2 SUB-MODULE
*
* Represents the climate
*    - based on the DICE model equations
*    - Radiative forcing for non CO2 ghgs
*    - parameters adjusted to the MAGICC6.4 model
*____________
* REFERENCES
* - "About the WITCH climate module"
*   witch\branches\climate\doc\TR-witch-cm.pdf
* - "Calibration of the WITCH carbon cycle to BERNcc from MAGICC6.4"
*   Modelling meeting presentation (16/04/2013)

#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SET m  'Climate layers' /
   atm    'Atmosphere'
   upp    'Upper Oceans'
   low    'Deep Oceans'
/;
alias (m,mm);
set mbox(m) /atm,upp,low/;    

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
   fex0     '2015 forcings of non-CO2 GHG [Wm-2]'                             / 0.5 /  #DICE2013: 0.25    #DICE2016: 0.5
   fex1     '2100 forcings of non-CO2 GHG [Wm-2]'                             / 1.0 /  #DICE2013: 0.70    #DICE2016: 1.0
;

##  PARAMETERS LOADED ----------------------------------
$gdxin '%datapath%data_mod_climate'
PARAMETER emi_gwp(*)        'Global warming potential over a time horizon of 100 years (2007 IPCC AR4) [GTonCO2eq/GTon]';
$load emi_gwp
PARAMETER tempc(*)          'Temperature update coefficients';
$load tempc
PARAMETER rfc(ghg,*)        'Radiative forcing update coefficients';
$load rfc

#.....................................................
# NOTE: this WITCH parameter has been UPDATED to
# 2015 VALUES (through one-cycle WITCH run)
#.....................................................
PARAMETER wcum_emi0(ghg,m)  'Initial world GHG emissions [GTon]';
$load wcum_emi0
PARAMETER cmphi(m,mm)       'Carbon Cycle transfert matrix with exchange coefficients';
$load cmphi


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Following parameters come from original WITCH climate and
# are kept only as reference.
# They are not needed inside current module.
#
# PARAMETER temp0(m) 'Initial temperature [deg C above preindustrial levels]';
# $loaddc temp0
#
# PARAMETER wcum_emi_eq(ghg)    'GHG stocks not subject to decay [GTon]';
# $load wcum_emi_eq
#
# PARAMETER emi_preind(ghg)     'Stocks of non-CO2 gases in pre-industrial [GTon]';
# $load emi_preind
#
# PARAMETER cmdec1(*)         'Yearly retention factor for non-co2 gases';
# $loaddc cmdec1
#
# PARAMETER cmdec2(*)         'One period retention factor for non-co2 ghg';
# $loaddc cmdec2
#
# * Calibrate on average runs with WITCH given MAGICC outputs
# PARAMETER rfaerosols(t) 'Radiative forcing from others (aerosols indirect and direct effects, ozone)';
# $loaddc rfaerosols
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
$gdxin


## load estimated fit from CO2 to OGHG forcing
Parameters oghg_coeff(*)  'Calibrated coefficients for OGHG-forcing related to CO2-forcing';
$gdxin '%datapath%data_ssp_iam.gdx'
$load   oghg_coeff
$gdxin


##  PARAMETERS EVALUATED -------------------------------
PARAMETERS
   wemi2qemi(ghg)    'Conversion factor W_EMI [GtC for CO2, Gt for others] into Q_EMI [GtonCeq]'
   wemi(ghg,t)       'World GHG emissions'
   forcoth(t)        'Exogenous forcing from other greenhouse gases'
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

* OGHG forcing exogenous
forcoth(t) =  fex0 + (1/17) * (fex1-fex0) * (t.val-1)$(t.val lt 18)  # Linear interpolation from fex0 (t1) to fex1 (t17),
           +  (fex1-fex0)$(t.val ge 18) ;                   # then (t > 17) level fixed to fex1

#.......................................................
# NOTE:
# Since we have emissions in CO2-CO2eq,
# but they are converted to carbon equivalent for
# the climate module, and emi_gwp is in [GTonCO2eq/GTon],
# therefore we need to convert the emi_gwp as well
#.......................................................

wemi2qemi(ghg)   =  emi_gwp(ghg) * CO2toC ;
wemi2qemi('co2') =  1;

##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
   W_EMI(ghg,t)       'World emissions [GTonC/year]'
   WCUM_EMI(ghg,m,t)  'Global stock of GHG [GTon]'
   RF(ghg,t)          'Radiative forcing [W/m2]'
   RFoth(t)           'Radiative forcing otherGHG as fraction of RFco2 [W/m2'
;
POSITIVE VARIABLES WCUM_EMI;

##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

* Stability level in absence of startboost
W_EMI.l('co2',t)$(not tfirst(t)) = sum(n, sigma(t,n)*ykali(t,n))   * CO2toC ;

# Stability for Emissions
W_EMI.up(ghg,t)   =  200 ;
W_EMI.lo(ghg,t)   = -100 ;
W_EMI.lo('co2',t) = -200 ;

WCUM_EMI.UP(ghg,m,t) = 8000 ;   # consider the co2 bound fosslim = 6000
WCUM_EMI.LO(ghg,m,t) = 0.0001 ;
WCUM_EMI.fx(ghg,m,tfirst)$wcum_emi0(ghg,m) = wcum_emi0(ghg,m) ;

# Stability for Temperatures
RF.lo(ghg,t) = -10;
RF.up(ghg,t) =  40;


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

   eq_w_emi_co2      # world tstep co2-emissions
   eq_wcum_emi_co2   # accumulation of Carbon in the atmosphere / upper box / deep oceans
   eq_rf_co2         # CO2 radiative forcing
   eq_rf_oghg        # OGHG radiative forcing


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

# WORLD EMISSIONS --------------------------------------
* World CO2 emissions (in GTonC)
eq_w_emi_co2(t)..   W_EMI('co2',t)  =E=  ( (sum(n$reg(n), E(t,n)) + sum(n$(not reg(n)), E.l(t,n)) ) * CO2toC  )
                                     /   wemi2qemi('co2')  
$if set mod_emission_pulse           + emission_pulse('co2',t)                                     
                                     ; # Carbon

* Accumulation of CARBON in the atmosphere / upper box / deep oceans
eq_wcum_emi_co2(m,t+1)$mbox(m)..   WCUM_EMI('co2',m,t+1)  =E=  sum(mm, cmphi(mm,m) * WCUM_EMI('co2',mm,t))     # exchange transfer in matrix from previous values
                                                   +   (tstep * W_EMI('co2',t))$(sameas(m,'atm'))  ;   # + new emi-values added in atm level
                                                                                                       # Carbon
* CO2 radiative forcing
eq_rf_co2(t)..   RF('co2',t)  =E=  rfc('co2','alpha')*(log(WCUM_EMI('co2','atm',t))-log(rfc('co2','beta')))  ;

* OGHG radiative forcing
eq_rf_oghg(t)..   RFoth(t)  =E=  oghg_coeff('intercept') + oghg_coeff('slope') * RF('co2',t)  ;

* Total radiative forcing
eq_forc(t)..   FORC(t)  =E=  RF('co2',t) + RFoth(t)  
$if set mod_srm + geoeng_forcing*(wsrm(t) + sum(nn$reg(nn), (SRM(t,nn) - SRM.l(t,nn))))
;

* Global temperature increase from pre-industrial levels
eq_tatm(t+1)..   TATM(t+1)  =E=  TATM(t) +  tempc('sigma1')*(  FORC(t)
                                                               -  tempc('lambda')* TATM(t)
                                                               -  tempc('sigma2')*( TATM(t)-TOCEAN(t) )   );

* Ocean temperature
eq_tocean(t+1)..   TOCEAN(t+1)  =E= TOCEAN(t) + tempc('heat_ocean') * (TATM(t)-TOCEAN(t))  ;


##  AFTER SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='after_solve'

#............................................................
# NOTE:
# In order to propagate climate informations across regions
# (and make each other aware of resulting setting generated
# by parallel decisions), simulation climate-module phase
# is called.
#............................................................

* World CO2 emissions (in GTonC!)
W_EMI.l('co2',t)  =  (sum(n, E.l(t,n))  * CO2toC ) / wemi2qemi('co2') 
$if set mod_emission_pulse           + emission_pulse('co2',t)   
; #Carbon

* Accumulation of Carbon in the atmosphere / upper box / deep oceans
WCUM_EMI.l('co2',m,t+1)  =  sum(mm, cmphi(mm,m) * WCUM_EMI.l('co2',mm,t))    # exchange transfer in matrix from previous values
                         +  (tstep * W_EMI.l('co2',t))$(sameas(m,'atm')) ;   # + new emi-values added in atm level

* CO2 radiative forcing
RF.l('co2',t)  =  rfc('co2','alpha')*(log(WCUM_EMI.l('co2','atm',t)) - log(rfc('co2','beta')));

* OGHG radiative forcing
RFoth.l(t)  =  oghg_coeff('intercept') + oghg_coeff('slope') * RF.l('co2',t)  ;

* Total radiative forcing
FORC.l(t)  =  RF.l('co2',t) + RFoth.l(t)   
$if set mod_srm +geoeng_forcing*sum(n,SRM.l(t,n))
;

* Global temperature increase from pre-industrial levels
TATM.l(t+1)  =  TATM.l(t) +  tempc('sigma1')*( FORC.l(t)
                                                -  tempc('lambda')* TATM.l(t)
                                                -  tempc('sigma2')*(TATM.l(t)-TOCEAN.l(t))  );

* Ocean temperature
TOCEAN.l(t+1)  =  TOCEAN.l(t) + tempc('heat_ocean')*(TATM.l(t)-TOCEAN.l(t));

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
forcoth

# Variables --------------------------------------------
W_EMI
WCUM_EMI
RF
RFoth


$endif.ph



 modules/mod_climate_witchoghg.gms

* CLIMATE WITCH-OGHG SUB-MODULE
*
* Represents the climate
*    - based on the DICE model equations
*    - Radiative forcing for non CO2 ghgs
*    - parameters adjusted to the MAGICC6.4 model
*____________
* REFERENCES
* - "About the WITCH climate module"
*   witch\branches\climate\doc\TR-witch-cm.pdf
* - "Calibration of the WITCH carbon cycle to BERNcc from MAGICC6.4"
*   Modelling meeting presentation (16/04/2013)

#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

SET m  'Climate layers' /
  atm    'Atmosphere'
  upp    'Upper Oceans'
  low    'Deep Oceans'
/;
alias (m,mm);
set mbox(m) /atm,upp,low/;    

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
  wemi2qemi(ghg)    'Conversion factor W_EMI [GtC for CO2, Gt for others] into Q_EMI [GtonCeq]'
  wemi(ghg,t)       'World GHG emissions'
;

$gdxin '%datapath%data_mod_climate'
PARAMETER emi_gwp(*)        'Global warming potential over a time horizon of 100 years (2007 IPCC AR4) [GTonCO2eq/GTon]';
$load emi_gwp
PARAMETER tempc(*)          'Temperature update coefficients';
$load tempc
PARAMETER rfc(ghg,*)        'Radiative forcing update coefficients';
$load rfc

#++++++++++++++++++++++++++++++++++++++++++++++++++++++
# NOTE: this WITCH parameter has been UPDATED to 
# 2015 VALUES (through one-cycle WITCH run)
#++++++++++++++++++++++++++++++++++++++++++++++++++++++
PARAMETER wcum_emi0(ghg,m)  'Initial world GHG emissions [GTon]'; 
$load wcum_emi0
PARAMETER wcum_emi_eq(ghg)    'GHG stocks not subject to decay [GTon]';
$load wcum_emi_eq
PARAMETER emi_preind(ghg)     'Stocks of non-CO2 gases in pre-industrial [GTon]';
$load emi_preind
PARAMETER cmphi(m,mm)       'Carbon Cycle transfert matrix with exchange coefficients';
$load cmphi
PARAMETER cmdec1(*)         'Yearly retention factor for non-co2 gases';
$loaddc cmdec1
PARAMETER cmdec2(*)         'One period retention factor for non-co2 ghg';
$loaddc cmdec2
* Calibrate on average runs with WITCH given MAGICC outputs
PARAMETER rfaerosols(t) 'Radiative forcing from others (aerosols indirect and direct effects, ozone)';
$loaddc rfaerosols
$gdxin


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++
# NOTE: 
# Since we have emissions in CO2-CO2eq,
# but they are conveted to carbon equivalent for 
# the climate module, and emi_gwp is in [GTonCO2eq/GTon],
# therefore we need to convert the emi_gwp as well
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
wemi2qemi(ghg)   =  emi_gwp(ghg) * CO2toC ;                                                                                                                           
wemi2qemi('co2') =  1;


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
   W_EMI(ghg,t)            'World emissions [GTonC/year]'
   WCUM_EMI(ghg,m,t)       'Global stock of GHG [GTon]'
   RF(ghg,t)               'Radiative forcing [W/m2]'
;
POSITIVE VARIABLES WCUM_EMI;

* Stability in absence of startboost
W_EMI.l('co2', t)$(not tfirst(t)) = sum(n, sigma(t,n)*ykali(t,n)) * tstep * CO2toC  ;


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

# Stability for emissions
W_EMI.up(ghg,t)   =  200 ;
W_EMI.lo(ghg,t)   = -100 ;
W_EMI.lo('co2',t) = -200 ;

WCUM_EMI.UP(ghg,m,t) = 8000 ; # consider the co2 bound fosslim = 6000
WCUM_EMI.LO(ghg,m,t) = 0.0001 ;
WCUM_EMI.fx(ghg,m,tfirst)$wcum_emi0(ghg,m) = wcum_emi0(ghg,m) ;

# Stability for forcings
RF.lo(ghg,t) = -10;
RF.up(ghg,t) =  40;


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'
   eq_w_emi_co2        # world tstep co2-emissions
   eq_w_emi_oghg       # world tstep oghg-emissions
   eq_wcum_emi_co2     # accumulation of Carbon in the atmosphere / upper box / deep oceans
   eq_wcum_emi_oghg    # accumulation of OGHG in the atmosphere
   eq_rf_co2           # CO2 radiative forcing 
   eq_rf_oghg          # OGHG radiative forcing


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

* World CO2 emissions (in GTonC!) per 5-year block
 eq_w_emi_co2('co2',t)..   W_EMI('co2',t)  =E=  ( (sum(n$reg(n), E(t,n)) + sum(n$(not reg(n)), E.l(t,n)) )  * CO2toC  ) 
                                            /   wemi2qemi('co2') 
$if set mod_emission_pulse           + emission_pulse('co2',t)  
; # Carbon

* World OGHG emissions (in GTonCeq!) per 5-year block
 eq_w_emi_oghg(oghg,t)..   W_EMI(oghg ,t)  =E=  ( (sum(n$reg(n), EOGHG(oghg,t,n)) + sum(n$(not reg(n)), EOGHG.l(oghg,t,n)) ) * CO2toC) 
                                            /   wemi2qemi(oghg)  
$if set mod_emission_pulse           + emission_pulse(oghg,t)  
; # Carbon-eq

* Accumulation of Carbon in the atmosphere / upper box / deep oceans
eq_wcum_emi_co2(m,t+1)$mbox(m)..   WCUM_EMI('co2',m,t+1)  =E=  sum(mm, cmphi(mm,m) * WCUM_EMI('co2',mm,t))     # exchange transfer from previous values
                                                   +   (tstep * W_EMI('co2',t))$(sameas(m,'atm'))  ;   # new emi-values added in atm level

* Accumulation of OGHG in the atmosphere
eq_wcum_emi_oghg(oghg,t+1)..   WCUM_EMI(oghg,'atm',t+1)  =E=  WCUM_EMI(oghg,'atm',t) * cmdec1(oghg)**tstep
                                                          +   cmdec2(oghg) * (W_EMI(oghg,t) + W_EMI(oghg,t+1)) / 2
                                                          +   (1-cmdec1(oghg)**tstep) * wcum_emi_eq(oghg)  ;

* CO2 radiative forcing                    
eq_rf_co2(t)..   RF('co2',t)   =E=  rfc('co2','alpha')*(log(WCUM_EMI('co2','atm',t))-log(rfc('co2','beta')))  ;

* CH4, N2O, SLF and LLF radiative forcing
 eq_rf_oghg(oghg,t)..   RF(oghg,t)  =E=  rfc(oghg,'inter') * rfc(oghg,'fac')
                                     *   (   ( rfc(oghg,'stm') * WCUM_EMI(oghg,'atm',t) )**rfc(oghg,'ex')  
                                           - ( rfc(oghg,'stm') * emi_preind(oghg)  )**rfc(oghg,'ex')
                                         );

* Total radiative forcing
eq_forc(t)..   FORC(t)  =E=  sum(ghg, RF(ghg,t)) + rfaerosols(t)
$if set mod_srm + geoeng_forcing*(wsrm(t) + sum(nn$reg(nn), (SRM(t,nn) - SRM.l(t,nn))))
;

* Global temperature increase from pre-industrial levels                       
eq_tatm(t+1)..   TATM(t+1)  =E=  TATM(t) +  tempc('sigma1')*( FORC(t)
                                                                 -  tempc('lambda')* TATM(t)
                                                                 -  tempc('sigma2')*(TATM(t)-TOCEAN(t))  );

* Ocean temperature                  
eq_tocean(t+1)..   TOCEAN(t+1)  =E=  TOCEAN(t) + tempc('heat_ocean') * (TATM(t)-TOCEAN(t))   ;

##  AFTER SOLVE
#_________________________________________________________________________
$elseif.ph %phase%=='after_solve'

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# NOTE:
# In order to propagate climate informations across regions 
# (and make each other aware of resulting setting generated 
# by parallel decisions), simulation climate-module phase 
# is called.
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

* World CO2 emissions (in GTonC!)      
W_EMI.l('co2',t)  =  (sum(n E.l(t,n))  * CO2toC ) / wemi2qemi('co2') ; # Carbon
$if set mod_emission_pulse           + emission_pulse('co2',t) 
;

* World OGHG emissions (in GTonCeq!)
W_EMI.l(oghg ,t)  =  (sum(n, EOGHG.l(oghg,t,n)) * CO2toC )  / wemi2qemi(oghg) ; # Carbon-eq
$if set mod_emission_pulse           + emission_pulse(oghg,t) 
;

* Accumulation of Carbon in the atmosphere / upper box / deep oceans
WCUM_EMI.l('co2',m,t+1)  =  sum(mm, cmphi(mm,m) * WCUM_EMI.l('co2',mm,t))     # exchange transfer from previous values
                         +   (tstep * W_EMI.l('co2',t))$(sameas(m,'atm'))  ;  # new emi-values added in atm level

* Accumulation of OGHG in the atmosphere
WCUM_EMI.l(oghg,'atm',t+1)  =  WCUM_EMI.l(oghg,'atm',t) * cmdec1(oghg)**tstep
                            +   cmdec2(oghg) * (W_EMI.l(oghg,t)+W_EMI.l(oghg,t+1))/2
                            +   (1-cmdec1(oghg)**tstep) * wcum_emi_eq(oghg)  ;

* CO2 radiative forcing                    
RF.l('co2',t)  =  rfc('co2','alpha')*( log(WCUM_EMI.l('co2','atm',t)) - log(rfc('co2','beta')));

* CH4, N2O, SLF and LLF radiative forcing
RF.l(oghg,t)  =  rfc(oghg,'inter') * rfc(oghg,'fac')
              *   (   (rfc(oghg,'stm') * WCUM_EMI.l(oghg,'atm',t))**rfc(oghg,'ex')  
                    - (rfc(oghg,'stm') * emi_preind(oghg))**rfc(oghg,'ex')            );

* Total radiative forcing
FORC.l(t)  =  sum(ghg, RF.l(ghg,t)) + rfaerosols(t)  ;
$if set mod_srm +geoeng_forcing*W_SRM.l(t,n)
;

* Global temperature increase from pre-industrial levels                       
TATM.l(t+1)  =  TATM.l(t) +  tempc('sigma1')*( FORC.l(t)
                                                -  tempc('lambda')* TATM.l(t)
                                                -  tempc('sigma2')*(TATM.l(t)-TOCEAN.l(t))  );
* Ocean temperature                  
TOCEAN.l(t+1)  =  TOCEAN.l(t) + tempc('heat_ocean')*(TATM.l(t)-TOCEAN.l(t))  ;


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# parameters
forcoth

# variables
W_EMI
WCUM_EMI
RF


$endif.ph



 modules/mod_dac.gms

# MODULE TEMPLATE
*
* Short description 
#____________
# REFERENCES
* - 
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================


* activate with --dac=1

##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module 
$ifthen.ph %phase%=='conf'

*by default, DAC are the only source of negative emissions if activated
$setglobal noneg

*source https://iopscience.iop.org/article/10.1088/1748-9326/ac2db0#erlac2db0s2
$if %baseline%=='ssp1' $setglobal costdac 'low'
$if %baseline%=='ssp2' $setglobal costdac 'best'
$if %baseline%=='ssp3' $setglobal costdac 'high'
$if %baseline%=='ssp4' $setglobal costdac 'best'
$if %baseline%=='ssp5' $setglobal costdac 'low'

$if %baseline%=='ssp1' $setglobal residual_emissions 'low'
$if %baseline%=='ssp2' $setglobal residual_emissions 'medium'
$if %baseline%=='ssp3' $setglobal residual_emissions 'high'
$if %baseline%=='ssp4' $setglobal residual_emissions 'low'
$if %baseline%=='ssp5' $setglobal residual_emissions 'high'

$setglobal burden_share 'geo'

$setglobal max_cdr 40

## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing 
* sets the element that you need.
$elseif.ph %phase%=='sets'

## INCLUDE DATA
#_________________________________________________________________________
* In the phase INCLUDE_DATA you should declare and include all exogenous parameters. 
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it 
*                 - this is the only phase where we should have numbers...
$elseif.ph %phase%=='include_data'

Scalar twh2ej / 0.0036 /;

Scalar c2co2;
c2co2 = 44/12;

scalar dac_tot0 'Initial tot costs of dac [T$/GtonCO2]';

scalar dac_totfloor 'Floor total costs  [T$/GtonCO2]';

Parameter dac_totcost(t,n) 'LCOD [T$/GtonCO2]';

scalar capex 'fraction of LCOD due to investments' /0.4/;

scalar lifetime /20/; 

scalar dac_delta_en; #constant as in transport
dac_delta_en = 1 - exp( 1 / ( - lifetime + (0.01/2) * lifetime**2) ); #20: DAC lifetime

parameter capstorreg(n);
parameter totcapstor;

parameter mkt_growth_rate_dac(t,n);

Parameter mkt_growth_free_dac(t,n);
mkt_growth_free_dac(t,n) = 0.001/5; 

Parameter dac_learn(t,n);

Parameter wcum_dac(t);
wcum_dac(t)$(year(t) le 2015) = 0.001 * 5;

##  COMPUTE DATA
#_________________________________________________________________________
* In the phase COMPUTE_DATA you should declare and compute all the parameters 
* that depend on the data loaded in the previous phase. 
$elseif.ph %phase%=='compute_data'

dac_tot0 = 453 * 1e-3; # Source: RFF expert elicitation (Soheil Shayegh, 2020)
* DAC expansion constraint

$ifthen.cd %mkt_growth_dac%=='high'
mkt_growth_rate_dac(t,n) = 0.1; # of additionnal capacities

$elseif.cd %mkt_growth_dac%=='low'
mkt_growth_rate_dac(t,n) = 0.03; # of additionnal capacities

$else.cd 
mkt_growth_rate_dac(t,n)= 0.06; # of additionnal capacities
$endif.cd


$ifthen.cd %costdac%=='high'
dac_learn(t,n)= 0.06; # to reproduce 440 $/tonCO2 in 2050 with 2.2 GtCO2 of capacity, source: RFF expert elicitation (Soheil Shayegh, 2020)

$elseif.cd %costdac%=='low'
dac_learn(t,n)= 0.22; # to reproduce 124 $/tonCO2 in 2050 with 2.2 GtCO2 of capacity, source: RFF expert elicitation (Soheil Shayegh, 2020)

$else.cd 
dac_learn(t,n)= 0.136; # to reproduce 214 $/tonCO2 in 2050 with 2.2 GtCO2 of capacity, source: RFF expert elicitation (Soheil Shayegh, 2020)
$endif.cd

dac_totfloor = 100 * 1e-3; # long term floor cost
dac_totcost(t,n) = dac_tot0;

capstorreg(n) = sum(ccs_stor, ccs_stor_cap_max(n,'%ccs_stor_cap_max%',ccs_stor)) / c2co2;
totcapstor = sum(n, capstorreg(n));


##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase DECLARE VARS, you can DECLARE new variables for your module. 
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'

Positive variable E_NEG(t,n)         'Installed capacity of DAC [GtCO2/yr]';
Positive variable I_CDR(t,n)         'Yearly investment of DAC [T$/yr]';
Positive variable COST_CDR(t,n)      'Yearly total cost of DAC [T$/yr]';
Positive variable REV_CDR(t,n)        'Total revenues of DAC industry [T$/yr]';
Variable GOVSUR(t,n)                 'Government surplus [Trill 2005 USD / year]'; 

# VARIABLES STARTING LEVELS
* to help convergence
E_NEG.l(t,n) = 0;
GOVSUR.l(t,n) = 0;

##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
* DO NOT put VAR.l here! (use the declare_vars phase) 
$elseif.ph %phase%=='compute_vars'

##  STABILITY CONSTRAINTS --------
* to avoid errors/help the solver to converge
E_NEG.lo(t,n) = 1e-15; #such that E_NEG(tfirst)*depr^(tmax*tstep) > E_NEG.lo
COST_CDR.up(t,n) = 0.25*ykali(t,n); #max dac costs 25% of gross gdp, for stability
REV_CDR.up(t,n) = 0.5*ykali(t,n); #max dac revenues 50% of gross gdp, for stability
I_CDR.up(t,n) = 30/c2co2;

$ifthen.bs %burden_share%=="geo"

E_NEG.up(t,n) = capstorreg(n)/5697* %max_cdr%; 
* modify maximum capacity installed as a f of budget to mimic response of the energy system (calibrated from cumulative DAC in WITCH engage runs)
$if set cbudget E_NEG.up(t,n) = capstorreg(n)/5697* %max_cdr% / ( 1 + exp( 0.00631*(%cbudget%-1069) ) );

$elseif.bs %burden_share%=="epc"

E_NEG.up(t,n) = pop('2',n)/sum(nn,pop('2',nn)) * totcapstor/5697 * %max_cdr%; 
* modify maximum capacity installed as a f of budget to mimic response of the energy system (calibrated from cumulative DAC in WITCH engage runs)
$if set cbudget E_NEG.up(t,n) = pop('2',n) / sum(nn,pop('2',nn)) * totcapstor/5697 * %max_cdr% / ( 1 + exp( 0.00631*(%cbudget%-1069) ) );

$elseif.bs %burden_share%=="hist_resp"

$gdxin 'data_%n%/data_historical_values'
$load q_emi_valid_primap
$gdxin

E_NEG.up(t,n) = sum(yearlu,q_emi_valid_primap('co2ffi',yearlu,n)) / sum( (yearlu,nn),q_emi_valid_primap('co2ffi',yearlu,nn) ) * totcapstor/5697 * %max_cdr%; 
* modify maximum capacity installed as a f of budget to mimic response of the energy system (calibrated from cumulative DAC in WITCH engage runs)
$if set cbudget E_NEG.up(t,n) = sum(yearlu,q_emi_valid_primap('co2ffi',yearlu,n)) / sum( (yearlu,nn),q_emi_valid_primap('co2ffi',yearlu,nn) ) * totcapstor/5697 * %max_cdr% / ( 1 + exp( 0.00631*(%cbudget%-1069) ) );

$endif.bs 

I_CDR.up(t,n)$(year(t) gt 2100) = 0; #to avoid errors in the climate module

#fix investments before 2020
E_NEG.up(t,n)$(year(t) le 2020) = 1e-3*capstorreg(n)/totcapstor;

#values at tfirst
I_CDR.fx(tfirst,n) = 0;
E_NEG.fx(tfirst,n) = 1e-8;

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
* List of equations
* One per line.
$elseif.ph %phase%=='eql'

eq_depr_e_neg
eq_cost_cdr
eq_emi_stor_dac
eq_mkt_growth_dac
eq_rev_cdr     # total revenues of carbon removal  
eq_govbal
eq_netzero

##  EQUATIONS
#_________________________________________________________________________
* In the phase EQS, you can include new equations to the model.
* The equations are always included.
* Best practice : - condition your equation to be able to do a run with tfix(t) 
$elseif.ph %phase%=='eqs'

* Compute the depreciation of DAC
eq_depr_E_NEG(t,tp1,n)$(reg(n) and pre(t,tp1))..
    E_NEG(tp1,n) =E= E_NEG(t,n) * (1 - dac_delta_en)**tlen(t) +
                     tlen(t) * I_CDR(t,n) / (capex * lifetime * dac_totcost(t,n));

* Compute the total cost of emissions
eq_COST_CDR(t,n)$(reg(n))..
    COST_CDR(t,n) =E= I_CDR(t,n) + E_NEG(t,n) * dac_totcost(t,n) * (1-capex)  +
                      sum(ccs_stor, E_STOR(ccs_stor,t,n) * ccs_stor_cost(ccs_stor,n) ) * CtoCO2;
 
eq_emi_stor_dac(t,n)$(reg(n))..
    E_NEG(t,n) =E= sum(ccs_stor, E_STOR(ccs_stor,t,n)) * CtoCO2;

* DAC growth constraint
eq_mkt_growth_dac(t,tp1,n)$(reg(n) and pre(t,tp1))..
    I_CDR(tp1,n) / (capex * lifetime * dac_totcost(tp1,n) ) =L= I_CDR(t,n) / (capex * lifetime * dac_totcost(t,n) ) *
                                            (1 + mkt_growth_rate_dac(t,n))**tlen(t) +
                                            tlen(tp1) * mkt_growth_free_dac(tp1,n);

*DAC revenues
eq_REV_CDR(t,n)$reg(n)..             REV_CDR(t,n) =E= CPRICE(t,n) * E_NEG(t,n) * 1e-3;

*balance of government funds
eq_govbal(t,n)$(reg(n) and not tfix(t))..           
                                    GOVSUR(t,n) =E= CTX(t,n) - REV_CDR(t,n); 

eq_netzero(t,n)$(reg(n) and year(t) le 2100)..        0 =G= 0
$if set netzero                 + E_NEG(t,n) - EIND(t,n)
;

##  BEFORE SOLVE
#_________________________________________________________________________
* In the phase BEFORE_SOLVE, you can update parameters (fixed
* variables, ...) inside the nash loop and right before solving the
* model. This is typically done for externalities, spillovers, ...
$elseif.ph %phase%=='before_solve'

* cumulative DAC capital installed over time
loop((t,tp1)$(pre(t,tp1) and year(t) ge 2015),
           wcum_dac(tp1) = tlen(t) * sum(n, E_NEG.l(t,n)) + wcum_dac(t)
);

dac_totcost(t,n) = max(dac_tot0 * (wcum_dac(t) / wcum_dac('1'))**(-dac_learn(t,n)),dac_totfloor);

*in SSP3 and SSP4, no spillover across countries
$if %baseline%=="ssp3" dac_totcost(t,n)$(not tfirst(t)) = max(dac_tot0 * ( (sum(tt$(preds(t,tt)),E_NEG.l(tt,n)*tlen(tt)) + wcum_dac('1') ) / wcum_dac('1'))**(-dac_learn(t,n)),dac_totfloor);
$if %baseline%=="ssp4" dac_totcost(t,n)$(not tfirst(t)) = max(dac_tot0 * ( (sum(tt$(preds(t,tt)),E_NEG.l(tt,n)*tlen(tt)) + wcum_dac('1') ) / wcum_dac('1'))**(-dac_learn(t,n)),dac_totfloor);

##  GDX ITEMS
#_________________________________________________________________________
* List the items to be kept in the final gdx
$elseif.ph %phase%=='gdx_items'


#variables
E_NEG
I_CDR
dac_totcost
COST_CDR
REV_CDR
GOVSUR

#
totcapstor
capstorreg

$endif.ph


 modules/mod_emission_pulse.gms

*-------------------------------------------------------------------------------
* Module to compute the Social Cost of Carbon via an emission pulse
* after any witch run, run it with --mod_emission_pulse=ssp2_cba_noncoop --cooperation=coop and specify your existing results file (without "_results")
* First version: February 18th, 2019, Author: J. Emmerling
* All SCCs in the current year, to convert from 2005 to 2020 USD, multiply by the deflator 1.302318665
* takes the run (be sure to specify the originally used impact and climate modules!)
* MIU and S are fixed to the loaded file values
* all Social costs expressed in $(2005)/tCO2eq
*-------------------------------------------------------------------------------

$ifthen.ph %phase%=='conf'

* Testing, since it is no optimization (0 superbasic variables), using COOP with gamma=0 to get right SCC values from marginals and via pulse
*$setglobal cooperation 'coop' (needs to be set from the command line!)
$setglobal gamma 0

*Best practice: Set policy to the one used in the loaded run!
$setglobal policy cba

$setglobal emission_pulse 1 #unit is MtCO2eq
$setglobal nameout %mod_emission_pulse%_emission_pulse
$setglobal output_filename results_%nameout%

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='sets'

* for now requires mod_climate as witchco2 or wicthoghg
$if not %climate%=='witchco2' $if not %climate%=='witchoghg' $abort 'USER ERROR: witch co2 or oghg climate module required for mod_emission_pulse!'

*$if %impact%=="off" $abort 'USER ERROR: impacts required to estimate SCC via mod_emission_pulse!'
*$if not %cooperation%=="coop" $abort 'USER ERROR: cooperative mode required to correctly estimate SCC via mod_emission_pulse!'
*$if not %policy%=="cba" $abort 'USER ERROR: policy should be set to cba fro emission pulse based SCC computation'

alias(n, nref);
alias(t, tref);

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_data'

parameter emission_pulse(ghg,t);
# Pulse in 2020!
emission_pulse(ghg,t)=0;
emission_pulse('co2','2') = %emission_pulse%*1e-3*CO2toC / wemi2qemi('co2');
*emission_pulse('ch4','2') = %emission_pulse%*1e-3*CO2toC / wemi2qemi('ch4');
*emission_pulse('n2o','2') = %emission_pulse%*1e-3*CO2toC / wemi2qemi('n20');


*-------------------------------------------------------------------------------
$elseif.ph %phase%=='declare_vars'

variable C_nopulse(t,n);
variable YGROSS_nopulse(t,n);
variable S_nopulse(t,n);
variable E_nopulse(t,n);
variable EIND_nopulse(t,n);
variable ELAND_nopulse(t,n);
variable W_EMI_nopulse(ghg,t);
variable K_nopulse(t,n);
variable I_nopulse(t,n);
variable TATM_nopulse(t);
parameter scc_nopulse(t,n);
variable MIU_nopulse(t,n);
parameter tfp_nopulse(t,n);
$if set mod_natural_capital variable NAT_CAP_DAM_nopulse(type,t,n);
$gdxin '%resdir%results_%mod_emission_pulse%'
$loaddc C_nopulse=C
$loaddc YGROSS_nopulse=YGROSS
$loaddc S_nopulse=S
$loaddc E_nopulse=E
$loaddc EIND_nopulse=EIND
$loaddc ELAND_nopulse=ELAND
$loaddc W_EMI_nopulse=W_EMI
$loaddc K_nopulse=K
$loaddc I_nopulse=I
$loaddc TATM_nopulse=TATM
$loaddc scc_nopulse=scc
$loaddc MIU_nopulse=MIU
$loaddc tfp_nopulse=tfp
$if set mod_natural_capital $loaddc NAT_CAP_DAM_nopulse=NAT_CAP_DAM
$gdxin

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_vars'

ELAND.fx(t,n) = ELAND_nopulse.l(t,n);
MIU.fx(t,n) = MIU_nopulse.l(t,n);
I.l(t,n) = I_nopulse.l(t,n);
S.fx(t,n) = S_nopulse.l(t,n);
#S.up(t,n) = 1;#S_nopulse.l(t,n) + 0.1;
#S.lo(t,n) = 0;#S_nopulse.l(t,n) - 0.1;
*EIND.l(t,n) = EIND_nopulse.l(t,n);
*E.l(t,n) = E_nopulse.l(t,n) + (%emission_pulse%*1e-3)/CARD(n);
*W_EMI.l(ghg,t) = W_EMI_nopulse.l(ghg,t) + emission_pulse(ghg,t);
$if not set mod_natural_capital YGROSS.fx(t,n) = YGROSS_nopulse.l(t,n);
*also for TFP
tfp(t,n) = tfp_nopulse(t,n);
*-------------------------------------------------------------------------------
$elseif.ph %phase%=='after_solve'



*-------------------------------------------------------------------------------
$elseif.ph %phase%=='report'

Parameter damrt(t,n);
Parameter tatm_difference(t);
Parameter scc_pulse_simple(t,n);
Parameter scc_pulse_ramsey_global(t,n);
Parameter scc_pulse_ramsey_regional(t,n);
Parameter scc_pulse_ramsey_only_regional(t,n,n);
Parameter scc_discounted_only_regional(*,t,n);
$if set mod_natural_capital Parameter scc_nat_cap(*,t,n), scc_nat_cap_only_regional(*,t,n);
Parameter discount_rate(t);
discount_rate(t) = 0.03;

damrt(t,n) = -(C.l(t,n) - C_nopulse.l(t,n)); #positive values = damages in T$
tatm_difference(t)=TATM.l(t) - TATM_nopulse.l(t);

#for now compute SCC along the baseline, i.e., using arguments of welfare function at original level
C.l(t,n) = C_nopulse.l(t,n);

 #compute SCC
 scc_pulse_ramsey_global(tref,nref) =
  (sum(t$(year(t) ge year(tref)),
           ((sum(nn,C.l(t,nn)) / sum(nn,pop(t,nn)))**(-elasmu)) / ((sum(nn,C.l(tref,nn)) / sum(nn,pop(tref,nn)))**(-elasmu))
           * rr(t)
           * sum(n,damrt(t,n)))
           / (%emission_pulse%*1e-3)
            * (1e3)
       )
;

scc_pulse_ramsey_regional(tref,nref) =
  (sum(t$(year(t) ge year(tref)),
       sum(n,
           (C.l(t,n) / pop(t,n))**(-elasmu) / (C.l(tref,nref) / pop(tref,nref))**(-elasmu)
           * rr(t)
           * damrt(t,n))
           / (%emission_pulse%*1e-3)
            * (1e3)
           )
       )
;

scc_pulse_ramsey_only_regional(tref,nref,n) =
  (sum(t$(year(t) ge year(tref)),
           (C.l(t,n) / pop(t,n))**(-elasmu) / (C.l(tref,nref) / pop(tref,nref))**(-elasmu)
           * rr(t)
           * damrt(t,n)
           / (%emission_pulse%*1e-3)
            * (1e3)
           )
       )
;

scc_pulse_simple(tref,n) = (sum((t,nn)$(year(t) ge year(tref)), damrt(t,nn) * (1+discount_rate(t))**(-(year(t)-year(tref))) ) / (%emission_pulse%*1e-3)) * 1e3; # in T$/GtCO2 to $/tCO2eq, just simple discounted global value
#SCC aligned with IAWG with 3 different discount rates, allowing to separate regional impacts
scc_discounted_only_regional('2',tref,n) = (sum((t)$(year(t) ge year(tref)), damrt(t,n) * (1+0.02)**(-(year(t)-year(tref))) ) / (%emission_pulse%*1e-3)) * 1e3; # in T$/GtCO2 to $/tCO2eq, just simple discounted global value
scc_discounted_only_regional('3.5',tref,n) = (sum((t)$(year(t) ge year(tref)), damrt(t,n) * (1+0.035)**(-(year(t)-year(tref))) ) / (%emission_pulse%*1e-3)) * 1e3; # in T$/GtCO2 to $/tCO2eq, just simple discounted global value
scc_discounted_only_regional('5',tref,n) = (sum((t)$(year(t) ge year(tref)), damrt(t,n) * (1+0.05)**(-(year(t)-year(tref))) ) / (%emission_pulse%*1e-3)) * 1e3; # in T$/GtCO2 to $/tCO2eq, just simple discounted global value



$ifthen.nk set mod_natural_capital
scc_nat_cap('market',tref,nref) = 
  (sum(t$(year(t) ge year(tref)),
       sum(n,
           {
            (1-nat_cap_utility_share(n))* ([ (1-nat_cap_utility_share(n)) * ( (CPC.l(t,n))**theta(n) ) + nat_cap_utility_share(n) * ( (NAT_CAP_DAM.l('nonmarket',t,n) / pop(t,n) * 1e6)**theta(n) ) ]**((1-theta(n)-elasmu)/theta(n)) ) * ( CPC.l(t,nref)**(theta(n) - 1) ) 
           }
           /
           {
           (1-nat_cap_utility_share(nref))* ([ (1-nat_cap_utility_share(nref)) * ( (CPC.l(tref,nref))**theta(nref) ) + nat_cap_utility_share(nref) * ( (NAT_CAP_DAM.l('nonmarket',tref,nref) / pop(tref,nref) * 1e6)**theta(nref) ) ]**((1-theta(n)-elasmu)/theta(nref)) ) * (CPC.l(tref,nref))**(theta(nref) - 1)
           }
           * rr(t)
           * damrt(t,n))
           / (%emission_pulse%*1e-3)
            * (1e3)
           )
       )
;

scc_nat_cap('nonmarket',tref,nref) = 
  (sum(t$(year(t) ge year(tref)),
       sum(n,
           {
            (nat_cap_utility_share(n))* ([ (1-nat_cap_utility_share(n)) * ( (C.l(t,n) / pop(t,n))**theta(n) ) + nat_cap_utility_share(n) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',t,n) / pop(t,n))**theta(n) ) ]**((1-theta(n)-elasmu)/theta(n)) ) * (1e6 * NAT_CAP_DAM.l('nonmarket',t,n) / pop(t,n))**(theta(n) - 1)   
           }
            / 
           {
            (1-nat_cap_utility_share(nref))* ([ (1-nat_cap_utility_share(nref)) * ( (C.l(tref,nref) / pop(tref,nref))**theta(nref) ) + nat_cap_utility_share(nref) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',tref,nref) / pop(tref,nref))**theta(nref) ) ]**((1-theta(n)-elasmu)/theta(nref)) ) * (C.l(tref,nref) / pop(tref,nref))**(theta(nref) - 1)
           }
           * rr(t)
           * (-(NAT_CAP_DAM.l('nonmarket',t,n) - NAT_CAP_DAM_nopulse.l('nonmarket',t,n))) )
           / (%emission_pulse%*1e-3)
            * (1e3)
           )
       )
;

#now taking into account only regional impacts, and discounting to world average marginal utility
scc_nat_cap_only_regional('market',tref,nref) = 
  (sum(t$(year(t) ge year(tref)),
       sum(n$sameas(n,nref),
           {
            (1-nat_cap_utility_share(n))* ([ (1-nat_cap_utility_share(n)) * ( (CPC.l(t,n))**theta(n) ) + nat_cap_utility_share(n) * ( (NAT_CAP_DAM.l('nonmarket',t,n) / pop(t,n) * 1e6)**theta(n) ) ]**((1-theta(n)-elasmu)/theta(n)) ) * ( CPC.l(t,nref)**(theta(n) - 1) ) 
           }
           /
           {
#          (1-nat_cap_utility_share(nref))* ([ (1-nat_cap_utility_share(nref)) * ( (C.l(tref,nref) / pop(tref,nref))**theta(nref) ) + nat_cap_utility_share(nref) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',tref,nref) / pop(tref,nref))**theta(nref) ) ]**((1-theta(n)-elasmu)/theta(nref)) ) * (C.l(tref,nref) / pop(tref,nref))**(theta(nref) - 1)
#           sum(nn, pop(t,nn) * (1-nat_cap_utility_share(nn))* ([ (1-nat_cap_utility_share(nn)) * ( (CPC.l(tref,nn))**theta(nn) ) + nat_cap_utility_share(nn) * ( (NAT_CAP_DAM.l('nonmarket',tref,nn) / pop(tref,nn) * 1e6)**theta(nn) ) ]**((1-theta(n)-elasmu)/theta(nn)) ) * (CPC.l(tref,nn))**(theta(nn) - 1) ) /sum(nn,pop(t,nn))
          (1-nat_cap_utility_share(nref))* ([ (1-nat_cap_utility_share(nref)) * ( (C.l(t,nref) / pop(t,nref))**theta(nref) ) + nat_cap_utility_share(nref) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',t,nref) / pop(t,nref))**theta(nref) ) ]**((1-theta(n)-elasmu)/theta(nref)) ) * (C.l(t,nref) / pop(t,nref))**(theta(nref) - 1)
           }
           * (1+0.035)**(-(year(t)-year(tref)))
           * damrt(t,n))
           / (%emission_pulse%*1e-3)
            * (1e3)
           )
       )
;

scc_nat_cap_only_regional('nonmarket',tref,nref) = 
  (sum(t$(year(t) ge year(tref)),
       sum(n$sameas(n,nref),
           {
            (nat_cap_utility_share(n))* ([ (1-nat_cap_utility_share(n)) * ( (C.l(t,n) / pop(t,n))**theta(n) ) + nat_cap_utility_share(n) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',t,n) / pop(t,n))**theta(n) ) ]**((1-theta(n)-elasmu)/theta(n)) ) * (1e6 * NAT_CAP_DAM.l('nonmarket',t,n) / pop(t,n))**(theta(n) - 1)   
           }
            / 
           {
#          (1-nat_cap_utility_share(nref))* ([ (1-nat_cap_utility_share(nref)) * ( (C.l(tref,nref) / pop(tref,nref))**theta(nref) ) + nat_cap_utility_share(nref) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',tref,nref) / pop(tref,nref))**theta(nref) ) ]**((1-theta(n)-elasmu)/theta(nref)) ) * (C.l(tref,nref) / pop(tref,nref))**(theta(nref) - 1)
#           sum(nn, pop(t,nn) * (1-nat_cap_utility_share(nn))* ([ (1-nat_cap_utility_share(nn)) * ( (CPC.l(tref,nn))**theta(nn) ) + nat_cap_utility_share(nn) * ( (NAT_CAP_DAM.l('nonmarket',tref,nn) / pop(tref,nn) * 1e6)**theta(nn) ) ]**((1-theta(n)-elasmu)/theta(nn)) ) * (CPC.l(tref,nn))**(theta(nn) - 1) ) /sum(nn,pop(t,nn))
          (1-nat_cap_utility_share(nref))* ([ (1-nat_cap_utility_share(nref)) * ( (C.l(t,nref) / pop(t,nref))**theta(nref) ) + nat_cap_utility_share(nref) * ( (1e6 * NAT_CAP_DAM.l('nonmarket',t,nref) / pop(t,nref))**theta(nref) ) ]**((1-theta(n)-elasmu)/theta(nref)) ) * (C.l(t,nref) / pop(t,nref))**(theta(nref) - 1)
           }
           * (1+0.035)**(-(year(t)-year(tref)))
           * (-(NAT_CAP_DAM.l('nonmarket',t,n) - NAT_CAP_DAM_nopulse.l('nonmarket',t,n))) )
           / (%emission_pulse%*1e-3)
            * (1e3)
           )
       )
;

$endif.nk

$elseif.ph %phase%=='gdx_items'
C_nopulse
YGROSS_nopulse
S_nopulse
I_nopulse
E_nopulse
EIND_nopulse
TATM_nopulse
W_EMI_nopulse
MIU_nopulse
emission_pulse
scc_nopulse
damrt
tatm_difference
discount_rate
scc_pulse_ramsey_global
scc_pulse_ramsey_regional
scc_pulse_ramsey_only_regional
scc_pulse_simple
scc_discounted_only_regional
$if set mod_natural_capital scc_nat_cap
$if set mod_natural_capital scc_nat_cap_only_regional

$endif.ph



 modules/mod_emi_stor.gms

# MODULE TEMPLATE
*
* Short description 
#____________
# REFERENCES
* - 
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module 
$ifthen.ph %phase%=='conf'

* Assumption for leakage in % per year --leak_input=0.0001
$setglobal leak_input 0

* Value estimates to consider (low,best,high)
$if %baseline%=='ssp1' $setglobal ccs_stor_cost 'low'
$if %baseline%=='ssp2' $setglobal ccs_stor_cost 'best'
$if %baseline%=='ssp3' $setglobal ccs_stor_cost 'high'
$if %baseline%=='ssp4' $setglobal ccs_stor_cost 'best'
$if %baseline%=='ssp5' $setglobal ccs_stor_cost 'low'

$if %baseline%=='ssp1' $setglobal ccs_stor_cap_max 'low'
$if %baseline%=='ssp2' $setglobal ccs_stor_cap_max 'best'
$if %baseline%=='ssp3' $setglobal ccs_stor_cap_max 'high'
$if %baseline%=='ssp4' $setglobal ccs_stor_cap_max 'high'
$if %baseline%=='ssp5' $setglobal ccs_stor_cap_max 'high'

## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing 
* sets the element that you need.
$elseif.ph %phase%=='sets'

* -- Storage -- *
set ccs_stor   'different storage technologies' /
    aqui_on
    aqui_off
    oil_gas_no_eor_on
    oil_gas_no_eor_off
    eor_on
    eor_off
    ecbm
/;

set ccs_stor_aqui(ccs_stor) 'aquifer storage ON and OFF'/
    aqui_on
    aqui_off
/;

set ccs_stor_og_eor 'oil and gas storage ON and OFF, including eor'/
    oil_gas_on
    oil_gas_off
/;

set ccs_stor_og(ccs_stor) 'oil and gas storage ON and OFF, excluding eor'/
    oil_gas_no_eor_on
    oil_gas_no_eor_off
/;

set ccs_stor_eor(ccs_stor) ' eor'/
    eor_on
    eor_off
/;

set ccs_stor_estim 'low, best, high case of storage capacity'/
    low
    best
    high
/;

set ccs_stor_dist_cat 'how distances are referred to in the make data file' /
    aquif
    oil_gas_onshore
    oil_gas_offshore
    coal_beds
/;

set map_ccs_stor_og(ccs_stor_og,ccs_stor_og_eor,ccs_stor_eor) /
 oil_gas_no_eor_on.oil_gas_on.eor_on
 oil_gas_no_eor_off.oil_gas_off.eor_off
/
;

set map_ccs_stor_eor(ccs_stor_eor,ccs_stor_og_eor) /
eor_on.oil_gas_on
eor_off.oil_gas_off
/
;

set map_ccs_stor_dist_cat(ccs_stor_dist_cat,ccs_stor) /
    aquif.(aqui_on,aqui_off)
    oil_gas_onshore.(oil_gas_no_eor_on,eor_on)
    oil_gas_offshore.(oil_gas_no_eor_off,eor_off)
    coal_beds.ecbm
/;



## INCLUDE DATA
#_________________________________________________________________________
* In the phase INCLUDE_DATA you should declare and include all exogenous parameters. 
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it 
*                 - this is the only phase where we should have numbers...
$elseif.ph %phase%=='include_data'


Parameter ccs_leak_rate(ccs_stor,t,n);

Parameter ccs_stor_cap_max(n,ccs_stor_estim,ccs_stor); 

$gdxin '%datapath%data_mod_emi_stor'

parameter ccs_stor_cap_aqui(n,*) 'Storage capacity for aquifers storage';
$loaddc ccs_stor_cap_aqui

parameter ccs_stor_cap_ecbm(n,*) 'Storage capacity for coal bed storage';
$loaddc ccs_stor_cap_ecbm

parameter ccs_stor_cap_og(n,*) 'Storage capacity for oil and gas fields storage';
$loaddc ccs_stor_cap_og

parameter ccs_stor_cap_eor(n) 'Storage capacity for eor storage';
$loaddc ccs_stor_cap_eor

parameter ccs_stor_share_onoff(n,*) 'Share of storage capacity ONshore and OFFshore';
$loaddc ccs_stor_share_onoff

parameter ccs_stor_dist(n,*) 'average distance in the country for different storage types in [km]';
$loaddc ccs_stor_dist

parameter ccs_stor_cost_estim(ccs_stor,ccs_stor_estim) 'storage cost, [T$/GtonCO2]';
$loaddc ccs_stor_cost_estim
$gdxin

parameter ccs_stor_cost(ccs_stor,n) 'storage cost, [T$/GtonCO2]';
ccs_stor_cost(ccs_stor,n) = ccs_stor_cost_estim(ccs_stor,'%ccs_stor_cost%');

parameter ccs_stor_cap_og_onoff(n,ccs_stor_estim,ccs_stor_og_eor) 'storage capacity of oil and gas fields divided into ONshore and OFFshore GtCO2';
parameter ccs_stor_cap_max(n,ccs_stor_estim,ccs_stor)             'storage capacity of each storage type GtCO2';
parameter ccs_leak_rate(ccs_stor,t,n)                             '%/yr of cumulated stored CO2 leakages';

##  COMPUTE DATA
#_________________________________________________________________________
* In the phase COMPUTE_DATA you should declare and compute all the parameters 
* that depend on the data loaded in the previous phase. 
$elseif.ph %phase%=='compute_data'

* Storage capacity: total of aquifer dividing into ON and OFF
ccs_stor_cap_max(n,ccs_stor_estim,ccs_stor_aqui) = ccs_stor_cap_aqui(n,ccs_stor_estim) * ccs_stor_share_onoff(n,ccs_stor_aqui);

* Storage capacity: total of og, eor included
ccs_stor_cap_og_onoff(n,ccs_stor_estim,ccs_stor_og_eor) = ccs_stor_cap_og(n,ccs_stor_estim) * ccs_stor_share_onoff(n,ccs_stor_og_eor);

* Storage capacity: total of ecbm which is ON only
ccs_stor_cap_max(n,ccs_stor_estim,'ecbm') = ccs_stor_cap_ecbm(n,ccs_stor_estim);

* Storage capacity: total of eor dividing into ON and OFF
loop((ccs_stor_eor,ccs_stor_og_eor)$(map_ccs_stor_eor(ccs_stor_eor,ccs_stor_og_eor)),
     ccs_stor_cap_max(n,ccs_stor_estim,ccs_stor_eor) = ccs_stor_cap_eor(n)*ccs_stor_share_onoff(n,ccs_stor_og_eor)
);

* Storage capacity: total of og, eor excluded
loop((ccs_stor_og,ccs_stor_og_eor,ccs_stor_eor)$(map_ccs_stor_og(ccs_stor_og,ccs_stor_og_eor,ccs_stor_eor)),
   ccs_stor_cap_max(n,ccs_stor_estim,ccs_stor_og) = max(ccs_stor_cap_og_onoff(n,ccs_stor_estim,ccs_stor_og_eor)-ccs_stor_cap_max(n,ccs_stor_estim,ccs_stor_eor),1e-7)
);

ccs_leak_rate(ccs_stor,t,n) = %leak_input%;

##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase DECLARE VARS, you can DECLARE new variables for your module. 
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'

positive variable E_STOR(ccs_stor,t,n) 'quantity of co2 that is stored for each storage type [GtonC/yr]';

positive variable CUM_E_STOR(ccs_stor,t,n) 'cumulative quantity of co2 that is stored for each storage type [GtonC]';

Positive variable E_LEAK(t,n);


# VARIABLES STARTING LEVELS
* to help convergence
CUM_E_STOR.l(ccs_stor,t,n) =  1e-8;

##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
* DO NOT put VAR.l here! (use the declare_vars phase) 
$elseif.ph %phase%=='compute_vars'

CUM_E_STOR.fx(ccs_stor,tfirst,n) =  1e-8;
CUM_E_STOR.up(ccs_stor,t,n)$(not tfirst(t)) = max(ccs_stor_cap_max(n,'%ccs_stor_cap_max%',ccs_stor) / c2co2,1e-5);

##  STABILITY CONSTRAINTS --------
* to avoid errors/help the solver to converge

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
* List of equations
* One per line.
$elseif.ph %phase%=='eql'

    eq_stor_cum
    eq_emi_leak


##  EQUATIONS
#_________________________________________________________________________
* In the phase EQS, you can include new equations to the model.
* The equations are always included.
* Best practice : - condition your equation to be able to do a run with tfix(t) 
$elseif.ph %phase%=='eqs'

eq_stor_cum(ccs_stor,tp1,t,n)$(reg(n) and not tfirst(t) and pre(t,tp1))..
                CUM_E_STOR(ccs_stor,tp1,n) =e= CUM_E_STOR(ccs_stor,t,n) * (1 - ccs_leak_rate(ccs_stor,t,n))**tlen(t) + tlen(t) * E_STOR(ccs_stor,t,n); 

eq_emi_leak(t,n)$(reg(n))..
                E_LEAK(t,n) =e= sum(ccs_stor, (1 - (1 - ccs_leak_rate(ccs_stor,t,n))**tlen(t)) * CUM_E_STOR(ccs_stor,t,n)) / tlen(t);


##  FIX VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='fix_variables'
* This phase is done after the phase POLICY.
* You should fix all your new variables.

tfixvar(E_STOR,'(t,n)')

##  BEFORE SOLVE
#_________________________________________________________________________
* In the phase BEFORE_SOLVE, you can update parameters (fixed
* variables, ...) inside the nash loop and right before solving the
* model. This is typically done for externalities, spillovers, ...
$elseif.ph %phase%=='before_solve'


##  PROBLEMATIC REGIONS
#_________________________________________________________________________
* You enter this phase if any region is having difficulties in finding a solution.
* Before running it serially, you may have provide some ad-hoc help. 
$elseif.ph %phase%=='problematic_regions'



##  AFTER SOLVE
#_________________________________________________________________________
* In the phase AFTER_SOLVE, you compute what must be propagated across the 
* regions after one bunch of parallel solving.
$elseif.ph %phase%=='after_solve'


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  REPORT
#_________________________________________________________________________
* Post-solve evaluate report measures
$elseif.ph %phase%=='report'


##  GDX ITEMS
#_________________________________________________________________________
* List the items to be kept in the final gdx
$elseif.ph %phase%=='gdx_items'

#parameters
ccs_stor_cap_max

#variables
E_LEAK
E_STOR
CUM_E_STOR

$endif.ph



 modules/mod_impact_burke.gms

* IMPACT BURKE SUB-MODULE
*
* Burke's damage function implemented according to model regional detail
* REFERENCES
* - Burke et al. 2015
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

* Burke alternatives: | sr | lr | srdiff | lrdiff
$setglobal bhm_spec 'sr'

# RICH/POOR CUTOFF
* | median | avg |
$setglobal cutoff 'median'

# OMEGA EQUATION DEFINITION
* | simple | full |
$setglobal  omega_eq 'simple'

* Damages in the optimization ('' using the endogenous variable) or post-processed ('.l' using the level in the equation)
$setglobal dam_endo '' #'.l'

* Given the Burke extreme impact functions, use a damage cap by default
$setglobal damage_cap

* When running in simulation, OMEGA needs to be bounded below otherwise it hits the zero constraint
* Usage: '' is the normal OMEGA, '_UNBOUNDED' uses the lower bound
$setglobal omegabnd '' #default
$if set temp_region_exogen $setglobal omegabnd '_UNBOUNDED'

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
* Short run
    bhm_SR_T            'Short Run Temperature coeff'                      /  0.0127184 /
    bhm_SR_T2           'Short Run squared Temperature coeff'              / -0.0004871 /

* Long run
    bhm_LR_T            'Long-Run Temperature coeff'                       / -0.0037497 /
    bhm_LR_T2           'Long-Run squared Temperature coeff'               / -0.0000955 /

* Short run differentiated
    bhm_SRdiff_rich_T   'Short-Run diff, rich, Temperature coeff'          /  0.0088951 /
    bhm_SRdiff_rich_T2  'Short-Run diff, rich, squared Temperature coeff'  / -0.0003155 /
    bhm_SRdiff_poor_T   'Short-Run diff, poor, Temperature coeff'          /  0.0254342 /
    bhm_SRdiff_poor_T2  'Short-Run diff, poor, squared Temperature coeff'  / -0.000772  /

* Long run differentiated
    bhm_LRdiff_rich_T   'Long-Run diff, rich, Temperature coeff'           / -0.0026918 /
    bhm_LRdiff_rich_T2  'Long-Run diff, rich, squared Temperature coeff'   / -0.000022  /
    bhm_LRdiff_poor_T   'Long-Run diff, poor, Temperature coeff'           / -0.0186    /
    bhm_LRdiff_poor_T2  'Long-Run diff, poor, squared Temperature coeff'   /  0.0001513 /
;

PARAMETERS
* Impact function coefficients
   beta_bhm(*, n, t)        'Burke local damage coefficient'
* Rich/poor cutoff threshold
    rich_poor_cutoff(t)     'Threshold differentiating rich from poor countries [GDP per capita]'
    rank(t,n)               'Income GDP per-capita rank'
    ykalicap_median(t)      'World median GDP per capita'
    ykalicap_worldavg(t)    'World average GDP per capita'
;

$ifthen.exog set temp_region_exogen
SCALAR    omega_minimum           'Prevent OMEGA from hitting the 0 lower bound when temperature is exogenous';
omega_minimum = (-1 + 1e-4) ;
$endif.exog

##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

## MEDIAN CUTOFF EVALUATION ----------------------------
#...........................................................................
# Not trivial in GAMS,
# ranking code inspired by solution here:
# https://support.gams.com/gams:compute_the_median_of_a_parameter_s_values
#...........................................................................

* This is ugly and slow ranking, but it works:
rank(t,n) = sum(nn$((ykali(t,nn)*1e6/pop(t,nn)) gt (ykali(t,n)*1e6/pop(t,n))), 1) + 1;

* There could be a tie in median individuals.
* To be safe, average through the number of median individuals:
ykalicap_median(t) = sum(n$(rank(t,n) eq round(card(n)/2)), (ykali(t,n)*1e6/pop(t,n)))
                   / sum(n$(rank(t,n) eq round(card(n)/2)), 1);

* World Average could be an alternative cutoff threshold
ykalicap_worldavg(t) = sum(n,(ykali(t,n)*1e6)) / sum(n,pop(t,n));

$ifthen.coff %cutoff% == 'median'
* Rich countries threshold: median
rich_poor_cutoff(t) = ykalicap_median(t) ;
$else.coff
* Rich countries threshold: world AVG pro-capita GDP(t)
rich_poor_cutoff(t) = ykalicap_worldavg(t) ;
$endif.coff

##  IMPACT COEFFICIENTS --------------------------------
#....................................................................
# Needs for Burke-growth "beta_bhm" coefficients
# Note: Burke impact function is also often indicated
# with delta(T) symbol:
# delta(n,t) = bhm1 * TEMP_REGION(n,t) + bhm2 * TEMP_REGION(n,t)^2
#...................................................................

*SR Baseline specification (SR, not differentiated)
$ifthen.bhm %bhm_spec%=='sr'
beta_bhm('T',  n, t) = bhm_SR_T  ;
beta_bhm('T2', n, t) = bhm_SR_T2 ;

*Lagged specification (5 years LDV)
$elseif.bhm %bhm_spec%=='lr'
beta_bhm('T',  n, t)  =  bhm_LR_T    ;
beta_bhm('T2', n, t)  =  bhm_LR_T2   ;

*Differentiated lagged values (short run for now since LR coefficients not in the paper nor SI) Rich for compared to mean income
$elseif.bhm %bhm_spec%=='srdiff'
#rich
beta_bhm('T',  n, t)$(((ykali(t,n)*1e6)/pop(t,n)) gt rich_poor_cutoff(t))  =  bhm_SRdiff_rich_T   ;
beta_bhm('T2', n, t)$(((ykali(t,n)*1e6)/pop(t,n)) gt rich_poor_cutoff(t))  =  bhm_SRdiff_rich_T2  ;
#poor
beta_bhm('T',  n, t)$(((ykali(t,n)*1e6)/pop(t,n)) le rich_poor_cutoff(t))  =  bhm_SRdiff_poor_T   ;
beta_bhm('T2', n, t)$(((ykali(t,n)*1e6)/pop(t,n)) le rich_poor_cutoff(t))  =  bhm_SRdiff_poor_T2  ;

*Differentiated lagged values (5 lagged values)
$elseif.bhm %bhm_spec%=='lrdiff'
#rich
beta_bhm('T',  n, t)$(((ykali(t,n)*1e6)/pop(t,n)) gt rich_poor_cutoff(t))  =  bhm_LRdiff_rich_T   ;
beta_bhm('T2', n, t)$(((ykali(t,n)*1e6)/pop(t,n)) gt rich_poor_cutoff(t))  =  bhm_LRdiff_rich_T2  ;
#poor
beta_bhm('T',  n, t)$(((ykali(t,n)*1e6)/pop(t,n)) le rich_poor_cutoff(t))  =  bhm_LRdiff_poor_T   ;
beta_bhm('T2', n, t)$(((ykali(t,n)*1e6)/pop(t,n)) le rich_poor_cutoff(t))  =  bhm_LRdiff_poor_T2  ;
$endif.bhm


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
    BIMPACT(t,n)             'Impact coefficient according to Burke equation'
    KOMEGA(t,n)              'Capital-Omega cross factor'
;
KOMEGA.lo(t,n) = 0;


# VARIABLES STARTING LEVELS ----------------------------
BIMPACT.l(t,n) = 0 ;
KOMEGA.l(t,n) = 1 ;

$ifthen.exog set temp_region_exogen
Variable        OMEGA_UNBOUNDED(t,n)     'Unbounded Omega';
OMEGA_UNBOUNDED.l(t,n) = 0;
$endif.exog

##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

##  STABILITY CONSTRAINTS ------------------------------
* to avoid errors/help the solver to converge
BIMPACT.lo(t,n) = (-1 + 1e-6) ; # needed because of eq_omega 

BIMPACT.fx(tfirst,n) = 0;

OMEGA.scale(t,n)  = 1e6 ;

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

eq_bimpact   # BHM yearly impact equation
eq_omega     # Impact over time equation
$if set temp_region_exogen eq_omega_unbounded
$if %omega_eq% == 'full' eq_komega     # Capital-Omega impact factor equation (only for full-omega)


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

##  BURKE'S IMPACT --------------------------------------
* BHM's yearly local impact
 eq_bimpact(t,n)$(reg(n) and ord(t) gt 1)..  BIMPACT(t,n)  =E=  beta_bhm('T', n, t) * ( TEMP_REGION_DAM%dam_endo%(t,n) - climate_region_coef('base_temp',n) )
                                            +   beta_bhm('T2', n, t)* ( power(TEMP_REGION_DAM%dam_endo%(t,n),2) - power(climate_region_coef('base_temp',n),2) ) ;

# OMEGA FULL
$ifthen.omg %omega_eq% == 'full'
* Omega full formulation
 eq_omega(t,n)$(reg(n) and not tlast(t))..  OMEGA%omegabnd%(t+1,n)  =E=  (  (1 + (OMEGA%omegabnd%(t,n)))
                                                                            #  TFP factor
                                                                            *  (tfp(t+1,n)/tfp(t,n))
                                                                            #  Pop factor
                                                                            *  ((( pop(t+1,n)/1000  )/( pop(t,n)/1000 ))**prodshare('labour',n)) * (pop(t,n)/pop(t+1,n))
                                                                            #  Capital-Omega factor
                                                                            *  KOMEGA(t,n)
                                                                            #  BHM impact on pc-growth
                                                                            /  ((1 + basegrowthcap(t,n) +  BIMPACT(t,n)   )**tstep)
                                                                        ) - 1  ;

* Capital-Omega factor
 eq_komega(t,n)$(reg(n))..  KOMEGA(t,n)  =E=  ( (((1-dk)**tstep) * K(t,n)  +  tstep * S(t,n) * tfp(t,n) * (K(t,n)**prodshare('capital',n)) * ((pop(t,n)/1000)**prodshare('labour',n)) * (1/(1+OMEGA%omegabnd%(t,n))) ) / K(t,n) )**prodshare('capital',n)  ;
# OMEGA SIMPLE
$else.omg
* Omega-simple formulation
 eq_omega(t,n)$(reg(n)  and not tlast(t))..  OMEGA%omegabnd%(t+1,n)  =E=  (  (1 + (OMEGA%omegabnd%(t,n))) / ((1 + BIMPACT(t,n))**tstep)  ) - 1  ;
$endif.omg


$ifthen.exog set temp_region_exogen
 eq_omega_unbounded(t,n)$(reg(n) and not tlast(t))..
   OMEGA(t,n)  =E=  ( OMEGA_UNBOUNDED(t,n) + omega_minimum + Sqrt( Sqr(OMEGA_UNBOUNDED(t,n) - omega_minimum) + Sqr(delta) ) )/2  ;
$endif.exog

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  REPORT
#_________________________________________________________________________
$elseif.ph %phase%=='report'

##  BURKE DAMAGES SIMULATED ----------------------------
* Here we simulate corresponding Burke damages (WITHOUT ABATE COSTS)
* from his growth-based original function, applied for each country:
* GDPcap(t+1) = GDPcap(t) * (1+basegrowth(t)+ bimpact(t))**tstep

PARAMETERS
       ynet_burkesim(t,n) 
    ynetcap_burkesim(t,n)
    damfrac_burkesim(t,n)  'Burke %damages over no-ClimateChange scenario using growth formula [%GDPssp]: (-) damage (+) gain'
    damages_burkesim(t,n)  'Burke absolute damages over no-ClimateChange scenario using growth formula [T$] (Trill 2005 USD): (-) damage (+) gain'
world_damfrac_burkesim(t)  'Burke-simulated world damages [%baseline]'
;

* Starting point
 ynetcap_burkesim(tfirst(t),n) = ykali('1',n)/pop('1',n);

* Simulation using pc-growth formula
 loop(t$(t.val < card(t)),    ynetcap_burkesim(t+1,n)  =  ynetcap_burkesim(t,n) * (( 1 + basegrowthcap(t,n) + BIMPACT.l(t,n) )**tstep)  ;   );

* Damages evaluation
    damfrac_burkesim(t,n) = (  (ynetcap_burkesim(t,n) - (ykali(t,n)/pop(t,n))) / (ykali(t,n)/pop(t,n))  ) * (100)  ;
    damages_burkesim(t,n) = damfrac_burkesim(t,n) * ykali(t,n) ;
       ynet_burkesim(t,n) = ynetcap_burkesim(t,n) * pop(t,n)   ;
world_damfrac_burkesim(t) = (sum(n,ynet_burkesim(t,n)) - sum(n,ykali(t,n))) / sum(n,ykali(t,n)) * 100 ;


##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
rich_poor_cutoff
ykalicap_median
ykalicap_worldavg
damfrac_burkesim
damages_burkesim
ynetcap_burkesim
ynet_burkesim
world_damfrac_burkesim

# Variables --------------------------------------------
BIMPACT
KOMEGA


$endif.ph



 modules/mod_impact_climcost.gms

*-------------------------------------------------------------------------------
* Long-run Damages from Climate Change
* - Economic impacts
* - Adaptation
*-------------------------------------------------------------------------------

$ifthen.ph %phase%=='conf'

* Define damage cost function
$setglobal damcost 'climcost'

$elseif.ph %phase%=='sets'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='include_data'

$gdxin '%datapath%data_mod_damage'

parameter comega(*,n,*);
$loaddc comega

parameter temp_base(*) 'temperature adjustment for the damage function';
$loaddc temp_base
temp_base('%damcost%') = 0.85;

$gdxin

* Adaptation efficiency

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_data'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='declare_vars'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_vars'

TATM.lo(t) = 0.85;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='eql'

eqomega

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='eqs'

**damage function
eqomega(t,n)$(reg(n) and not tfirst(t))..
                OMEGA(t,n) =e= 1 *
                                     (comega('%damcost%',n,'b1') * (TATM(t) - temp_base('%damcost%')) +
                                      comega('%damcost%',n,'b2') * (TATM(t) - temp_base('%damcost%'))**2 +
                                      comega('%damcost%',n,'c')
                                     )
;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='report'


$elseif.ph %phase%=='gdx_items'

* Parameters
comega


$endif.ph



 modules/mod_impact_coacch.gms

*-------------------------------------------------------------------------------
* Long-run Damages from Climate Change
* - Economic impacts
* - Adaptation to SLR (with mod_slr)
* based on Wijst, K. van der, et al. New Damage Curves and Multimodel Analysis Suggest Lower Optimal Temperature. Nature Climate Change, March 23, 2023. https://doi.org/10.1038/s41558-023-01636-1.
*-------------------------------------------------------------------------------

$ifthen.ph %phase%=='conf'

* Define damage cost function
* chose percentile of the damage function (default=median p50)
$setglobal damcostpb 'p50'

$setglobal damcost 'COACCH_NoSLR'

*$setglobal damcostslr 'COACCH_SLR_NoAd'
*$setglobal damcostslr 'COACCH_SLR_Ad'
$setglobal damcostslr 'none'

$if not set mod_slr $if not '%damcostslr%'=='none' $abort("COACCH damage function with SLR impacts require --mod_slr=1 for Sea-level rise")

$elseif.ph %phase%=='sets'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='include_data'

$gdxin '%datapath%data_mod_damage'

parameter comega(*,n,*);
$loaddc comega

parameter comega_slr(*,n,*);
$loaddc comega_slr

*for non-convex functions
*comega_slr('COACCH_SLR_Ad',n,'b2')$(comega_slr('COACCH_SLR_Ad',n,'b2') le 0)=0;
*comega_slr('COACCH_SLR_NoAd',n,'b2')$(comega_slr('COACCH_SLR_NoAd',n,'b2') le 0)=0;

*no positive impacts from SLR possible
comega_slr('COACCH_SLR_Ad',n,'b1')$(comega_slr('COACCH_SLR_Ad',n,'b1') le 0)=0;
comega_slr('COACCH_SLR_NoAd',n,'b1')$(comega_slr('COACCH_SLR_NoAd',n,'b1') le 0)=0;

*zero values for running without SLR damages
comega_slr('none',n,'b1') = 0;
comega_slr('none',n,'b2') = 0;

parameter comega_qmul(*,n,*) 'Damage function quantile multiplier';
$loaddc comega_qmul

comega_qmul('%dmgcostslr%',n,'p05')$(comega_qmul('%dmgcostslr%',n,'p05') le 0) = 0;
comega_qmul('%dmgcost%',n,'p05')$(comega_qmul('%dmgcost%',n,'p05') le 0) = 0;

comega_qmul('%dmgcostslr%',n,'p05')$(comega_qmul('%dmgcostslr%',n,'p025') le 0) = 0;
comega_qmul('%dmgcost%',n,'p05')$(comega_qmul('%dmgcost%',n,'p025') le 0) = 0;

parameter temp_base(*) 'temperature adjustment for the damage function';
$loaddc temp_base
$gdxin

* Adaptation efficiency

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_data'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='declare_vars'

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='compute_vars'

TATM.lo(t) = tatm0;


*-------------------------------------------------------------------------------
$elseif.ph %phase%=='eql'

eqomega

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='eqs'

**damage function
eqomega(t,n)$(reg(n) and not tfirst(t))..
                OMEGA(t,n) =e= comega_qmul('%damcost%',n,'%damcostpb%') *
                                     (comega('%damcost%',n,'b1') * (TATM(t) - temp_base('%damcost%')) +
                                      comega('%damcost%',n,'b2') * (TATM(t) - temp_base('%damcost%'))**2 +
                                      comega('%damcost%',n,'c')
$if set mod_slr                    + comega_qmul('%damcostslr%',n,'%damcostpb%') * (comega_slr('%damcostslr%',n,'b1') * GMSLR(t) + comega_slr('%damcostslr%',n,'b2') * GMSLR(t)**2)
                                     )
- comega_qmul('%damcost%',n,'%damcostpb%') *
                                     (comega('%damcost%',n,'b1') * (TATM('2') - temp_base('%damcost%')) +
                                      comega('%damcost%',n,'b2') * (TATM('2') - temp_base('%damcost%'))**2 +
                                      comega('%damcost%',n,'c')
$if set mod_slr                    + comega_qmul('%damcostslr%',n,'%damcostpb%') * (comega_slr('%damcostslr%',n,'b1') * GMSLR('2') + comega_slr('%damcostslr%',n,'b2') * GMSLR('2')**2)
                                     ) ;

*-------------------------------------------------------------------------------
$elseif.ph %phase%=='report'


$elseif.ph %phase%=='gdx_items'

* Parameters
comega
comega_slr
comega_qmul


$endif.ph



 modules/mod_impact_dell.gms

* IMPACT DELL SUB-MODULE
* DELL's damage function implemented according to model regional detail (n)
*____________
* REFERENCES
* - Dell et al. 2014
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

# RICH/POOR CUTOFF
* | median | avg |
$setglobal cutoff 'median'

# OMEGA EQUATION DEFINITION
* | simple | full |
$setglobal  omega_eq 'simple'

* Given the Dell extreme impact functions, use a damage cap by default
$setglobal damage_cap

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
    djo_rich   'rich DJO temperature coeff' / 0.00261/
;

PARAMETERS
* Impact function coefficients
    beta_djo(*, n, t)      'DJO local damage coefficient'
* Rich/poor cutoff threshold
    rich_poor_cutoff(t)    'Threshold differentiating rich from poor countries (GDPcap)'
    rank(t,n)              'Income rank'
    ykalipc_median(t)      'World median GDP per capita'
    ykalipc_worldavg(t)    'World average GDP per capita'
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

* This is ugly and slow ranking, but it works:
rank(t,n) = sum(nn$((ykali(t,nn)*1e6/pop(t,nn)) gt (ykali(t,n)*1e6/pop(t,n))), 1) + 1;

* There could be a tie in median individuals.
* To be safe, average through the number of median individuals:
ykalipc_median(t) = sum(n$(rank(t,n) eq round(card(n)/2)), (ykali(t,n)*1e6/pop(t,n)))
                  / sum(n$(rank(t,n) eq round(card(n)/2)), 1);

* World Average could be an alternative cutoff threshold
ykalipc_worldavg(t) = sum(n,(ykali(t,n)*1e6)) / sum(n,pop(t,n));

$ifthen.coff %cutoff% == 'median'
* Rich countries threshold: median
rich_poor_cutoff(t) = ykalipc_median(t) ;
$else.coff
* Rich countries threshold: world AVG pro-capita GDP(t)
rich_poor_cutoff(t) = ykalipc_worldavg(t) ;
$endif.coff

##  IMPACT COEFFICIENTS --------------------------------
* Rich coeffs
beta_djo('T',  n, t)$(((ykali('1',n)*1e6)/pop('1',n)) gt rich_poor_cutoff('1'))  =  0.00261;
* Poor coeffs
beta_djo('T',  n, t)$(((ykali('1',n)*1e6)/pop('1',n)) le rich_poor_cutoff('1'))  =  0.00261 - 0.01655;


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
    DJOIMPACT(t,n)       'Impact coefficient according to DJO equation'
    KOMEGA(t,n)              'Capital-Omega cross factor'
    DAMFRAC_UNBOUNDED(t,n)   'Potential unbounded damages, as GDP Gross fraction [%GDPgross]: (+) damages (-) gains '
    YNET_UNBOUNDED(t,n)      'Potential unbounded GDP, net of damages [Trill 2005 USD / year]'
    YNET_UPBOUND(t,n)        'Potential GDP, net of damages, bounded in maximum gains [Trill 2005 USD / year]'
;
KOMEGA.lo(t,n) = 0;

# VARIABLES STARTING LEVELS ----------------------------
KOMEGA.l(t,n) = 1 ;
DJOIMPACT.l(t,n) = 0 ;


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

##  STABILITY CONSTRAINTS ------------------------------
* to avoid errors/help the solver to converge
DJOIMPACT.lo(t,n) = (-1 + 1e-5) ; # needed because of eq_omega
DJOIMPACT.fx(tfirst,n) = 0;

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'
eq_omega      # Yearly impact equation 
eq_djoimpact  # DJO tstep impact equation
$if %omega_eq% == 'full' eq_komega     # Capital-Omega impact factor equation (only for full-omega)


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

##  DJO'S IMPACT --------------------------------------
* DJO's yearly local impact
 eq_djoimpact(t,n)$(reg(n) and not tfirst(t))..  DJOIMPACT(t,n)  =E=  beta_djo('T',n,t) * (TEMP_REGION_DAM(t,n)-climate_region_coef('base_temp',n))  ;             

# OMEGA FULL
$ifthen.omg %omega_eq% == 'full'
* Omega full formulation
 eq_omega(t,n)$(reg(n) and not tlast(t))..  OMEGA(t+1,n)  =E=  (  (1 + (OMEGA(t,n)))
                                                                            #  TFP factor
                                                                            *  (tfp(t+1,n)/tfp(t,n))
                                                                            #  Pop factor
                                                                            *  ((( pop(t+1,n)/1000  )/( pop(t,n)/1000 ))**prodshare('labour',n)) * (pop(t,n)/pop(t+1,n))
                                                                            #  Capital-Omega factor
                                                                            *  KOMEGA(t,n)
                                                                            #  BHM impact on pc-growth
                                                                            /  ((1 + basegrowthcap(t,n) +  DJOIMPACT(t,n)   )**tstep)
                                                                        ) - 1  ;
* Capital-Omega factor
 eq_komega(t,n)$(reg(n))..  KOMEGA(t,n)  =E=  ( (((1-dk)**tstep) * K(t,n)  +  tstep * S(t,n) * tfp(t,n) * (K(t,n)**prodshare('capital',n)) * ((pop(t,n)/1000)**prodshare('labour',n)) * (1/(1+OMEGA(t,n))) ) / K(t,n) )**prodshare('capital',n)  ;
# OMEGA SIMPLE
$else.omg
* Omega-simple formulation
 eq_omega(t,n)$(reg(n)  and not tlast(t))..  OMEGA(t+1,n)  =E=  (  (1 + (OMEGA(t,n))) / ((1 + DJOIMPACT(t,n))**tstep)  ) - 1  ;
$endif.omg


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
rich_poor_cutoff
ykalipc_median
ykalipc_worldavg

# Variables --------------------------------------------
DJOIMPACT
KOMEGA


$endif.ph




 modules/mod_impact_dice.gms

* IMPACT DICE SUB-MODULE
** A DICE2016-like impact is uniformly applied across all regions
*____________
* REFERENCES
* - Nordhaus, William. "Projections and Uncertainties about Climate Change in an Era of Minimal Climate Policies". 
* American Economic Journal: Economic Policy 10, no. 3 (1 August 2018): 33360. https://doi.org/10.1257/pol.20170046.
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'


## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
* DICE-2016 damage coefficient
   a1       'Damage intercept'                          / 0       /
   a2       'Damage quadratic term'                     / 0.00236 /
   a3       'Damage exponent'                           / 2.00    /
;


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'


## List of equations
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

eq_omega


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

 eq_omega(t,n)$(reg(n) and not tfirst(t))..   OMEGA(t,n)  =E=  ( (a1 * TATM(t)) + (a2 * power(TATM(t),a3)) ) - ( (a1 * TATM('2')) + (a2 * power(TATM('2'),a3)) ) ;


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# parameters
a1
a2
a3


$endif.ph



 modules/mod_impact_kalkuhl.gms

* IMPACT BURKE SUB-MODULE
*
* Burke's damage function implemented according to model regional detail
* REFERENCES
* - Burke et al. 2015
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'

# OMEGA EQUATION DEFINITION
* | simple | full |
$setglobal  omega_eq 'simple'


## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
* Short run
    kw_DT          / 0.00641  /
    kw_DT_lag      / 0.00345  /
    kw_TDT         / -.00105  /
    kw_TDT_lag     / -.000718 /
    kw_T           / -.00675  /
;


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES
    BIMPACT(t,n)             'Impact coefficient according to Burke equation'
    KOMEGA(t,n)              'Capital-Omega cross factor'
;
KOMEGA.lo(t,n) = 0;


# VARIABLES STARTING LEVELS ----------------------------
BIMPACT.l(t,n) = 0 ;
KOMEGA.l(t,n) = 1 ;

##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

##  STABILITY CONSTRAINTS ------------------------------
* to avoid errors/help the solver to converge
BIMPACT.lo(t,n) = (-1 + 1e-6) ; # needed because of eq_omega

#since requires lags fixed first period
#BIMPACT.fx('1',n)  =  (kw_DT+kw_DT_lag) * ((TEMP_REGION_DAM_INCPAST.l('1',n) - TEMP_REGION_DAM_INCPAST.l('0',n)) / tlen('1') )
#+   (kw_TDT+kw_TDT_lag) * (( TEMP_REGION_DAM_INCPAST.l('1',n) - TEMP_REGION_DAM_INCPAST.l('0',n) ) / tlen('1'))  * ( 2*(TEMP_REGION_DAM_INCPAST.l('1',n)-TEMP_REGION_DAM_INCPAST.l('0',n)) + 5 *(TEMP_REGION_DAM_INCPAST.l('0',n)) );
BIMPACT.fx(t,n)$(year(t) le 2020) = 0;
#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
$elseif.ph %phase%=='eql'

eq_bimpact   # BHM yearly impact equation
eq_omega     # Impact over time equation
$if %omega_eq% == 'full' eq_komega     # Capital-Omega impact factor equation (only for full-omega)


##  EQUATIONS
#_________________________________________________________________________
$elseif.ph %phase%=='eqs'

##  BURKE'S IMPACT --------------------------------------
* BHM's yearly local impact
# eq_bimpact(t,n)$(reg(n) and ord(t) gt 1)..  BIMPACT(t,n)  =E=  (kw_DT+kw_DT_lag) * ((TEMP_REGION_DAM(t,n)-TEMP_REGION_DAM(t-1,n))/tlen(t))
#                                            +   (kw_TDT+kw_TDT_lag) * ((TEMP_REGION_DAM(t,n)-TEMP_REGION_DAM(t-1,n))/tlen(t)) * TEMP_REGION_DAM(t-1,n);
  eq_bimpact(t,n)$(reg(n) and ord(t) gt 2)..  BIMPACT(t,n)  =E=  (kw_DT+kw_DT_lag) * ((TEMP_REGION_DAM(t,n)-TEMP_REGION_DAM(t-1,n)))
                                            +   (kw_TDT+kw_TDT_lag) *(TEMP_REGION_DAM(t,n)-TEMP_REGION_DAM(t-1,n))/tlen(t) * ( 2*(TEMP_REGION_DAM(t,n)-TEMP_REGION_DAM(t-1,n)) + 5 *(TEMP_REGION_DAM(t-1,n)) )
#
;
# OMEGA FULL
$ifthen.omg %omega_eq% == 'full'
* Omega full formulation
 eq_omega(t,n)$(reg(n) and not tlast(t))..  OMEGA(t+1,n)  =E=  (  (1 + (OMEGA(t,n)))
                                                                            #  TFP factor
                                                                            *  (tfp(t+1,n)/tfp(t,n))
                                                                            #  Pop factor
                                                                            *  ((( pop(t+1,n)/1000  )/( pop(t,n)/1000 ))**prodshare('labour',n)) * (pop(t,n)/pop(t+1,n))
                                                                            #  Capital-Omega factor
                                                                            *  KOMEGA(t,n)
                                                                            #  BHM impact on pc-growth
                                                                            /  ((1 + basegrowthcap(t,n) +  BIMPACT(t,n)   )**tstep)
                                                                        ) - 1  ;

* Capital-Omega factor
 eq_komega(t,n)$(reg(n))..  KOMEGA(t,n)  =E=  ( (((1-dk)**tstep) * K(t,n)  +  tstep * S(t,n) * tfp(t,n) * (K(t,n)**prodshare('capital',n)) * ((pop(t,n)/1000)**prodshare('labour',n)) * (1/(1+OMEGA(t,n))) ) / K(t,n) )**prodshare('capital',n)  ;
# OMEGA SIMPLE
$else.omg
* Omega-simple formulation
# eq_omega(t,n)$(reg(n)  and not tlast(t))..  OMEGA(t+1,n)  =E=  (  (1 + (OMEGA(t,n))) / ((1 + BIMPACT(t,n))**tstep)  ) - 1  ;
  eq_omega(t,n)$(reg(n)  and not tlast(t))..  OMEGA(t+1,n)  =E=  1/(BIMPACT(t+1,n)+1/(1+OMEGA(t,n)))-1 ;
$endif.omg


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  REPORT
#_________________________________________________________________________
$elseif.ph %phase%=='report'


##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Variables --------------------------------------------
BIMPACT
KOMEGA


$endif.ph



 modules/mod_inequality.gms

# mod_inequality
*
* Short description
*activate with --mod_inequality=1
*integrate with utility function with --welfare_inequality=1
#____________
# REFERENCES
* -
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

# --welfare_inequality=1 activates internal inequality integration in the utility function
# --transfer=="OPTION" activates redistribution of carbon tax
# OPTIONS =   
#   - endo = endogenous redistribution of the carbon tax
#   - scheme = exogenous redistribution of the carbon tax, governed by el_redist
# --neg_redist=y/n requires transfer=="endo" or "epc" (ie gov_redist_ctax activated) and allows for "negative redistribution" for net negative emissions
# TO CALIBRATE damage elasticity:
# STEP 1: run --calib_damages=1, without policy specification, with the parameters you want to run (xi, omega, impact fun, quantiles time dependency)
# STEP 2: run the policy you wish, with the same specifications and --use_calib=1

# inequality parameters are declared x*10 for readibility of the result .gdx 
# write a zero before the number for decimals <1
# eg. xi 05 == 0.5

##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module
$ifthen.ph %phase%=='conf'

$If not exist "%datapath%data_mod_inequality_converted.gdx" $abort "Please run the translate_rice50x_data.R script again, uncommenting the last line ["source('input/convert_mod_inequality.R')]""

* Omega: takes values between 0 and 2
* 1 is the neutral value
$setglobal omega 05

* Elasticity to damages across quantiles: takes values between [-1;+1]
* 1 is the neutral value
$setglobal xi 85

* Elasticity of redistribution across quantiles for exogenous transfer schemes
$setglobal el_redist 0

* Internal inequality aversion
* Range: [0,1.5]; good options: | 0 | 0.5 | 1.45
$setglobal gammaint 50

* calibrate omega from Budolfson 2021
$setglobal omegacalib

* cap MIU to one
$setglobal max_miuup 1


$if not set calib_damages $setglobal welfare_inequality
$if set calib_damages $setglobal policy "bau_impact"
$if set calib_damages $setglobal transfer "neutral"

#policy flag
$if not set transfer  $setglobal transfer "neutral"
$if %transfer%=="epc" $setglobal el_redist 0

$if set calib_damages $setglobal nameout "calib_%baseline%_IMP%impact%_XI%xi%_Q%quant%"

*activate alternative utility function argument if active
$if set welfare_inequality $setglobal alternative_utility

## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing
* sets the element that you need.
$elseif.ph %phase%=='sets'

set dist / D1*D10/;
alias(dist,ddist);

set ineq_elast / 'damages',
                 'abatement',
                 'redist'/; 

## INCLUDE DATA
#_________________________________________________________________________
* In the phase INCLUDE_DATA you should declare and include all exogenous parameters.
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it
*                 - this is the only phase where we should have numbers...
$elseif.ph %phase%=='include_data'

Scalar deltain /1e-3/;

Scalar gammaint;
gammaint = %gammaint%/100; 

Parameters quantiles_ref(t,n,dist);
Parameters inequality_parameters(t,n,*);

*to allow for quantiles of different sizes (eg deciles together with percentiles)
Parameter quant_share(dist); 
quant_share(dist) = 1/card(dist);

Parameter subsistance_level / 273.3 / ; # half of 1.9USDpc/day in 2005 US$/yr 
Parameter y_dist_min(t,n,dist); 

* Inequality data

$ifthen.cd set use_calib
Parameter ineq_weights_calib(t,n,dist)
$gdxin 'results_calib_%baseline%_IMP%impact%_XI%xi%_Q%quant%'
$load ineq_weights_calib = ineq_calib # inequality_parameters
$gdxin
$endif.cd 

Parameter quantiles_ref_ssp(ssp,t,n,dist);

$gdxin '%datapath%data_mod_inequality_converted'
$load quantiles_ref_ssp = quantiles # inequality_parameters
$gdxin

* for regiond where no within-country inequality data is available, assume perfect equality
quantiles_ref_ssp('%baseline%',t,n,dist)$(not quantiles_ref_ssp('%baseline%',t,n,dist)) = 0.1;

Parameter ineq_weights(t,n,dist,ineq_elast); 
Parameter el_coeff(ineq_elast); 

el_coeff('damages') = %xi%/100; # elasticity of damage costs distribution among quantiles
el_coeff('redist') = %el_redist%/10; #elasticity of carbon tax redistribution scheme
el_coeff('abatement') = %omega%/10; # elasticity of abatement costs distribution among quantiles

##  COMPUTE DATA
#_________________________________________________________________________
* In the phase COMPUTE_DATA you should declare and compute all the parameters
* that depend on the data loaded in the previous phase.
$elseif.ph %phase%=='compute_data'

*minumum subsistance level 
y_dist_min(t,n,dist) = subsistance_level * quant_share(dist) * pop(t,n) * 1e-6;

quantiles_ref(t,n,dist) = quantiles_ref_ssp('%baseline%',t,n,dist); 
#constant after 2100
quantiles_ref(t,n,dist)$(ord(t) gt 18) = quantiles_ref_ssp('%baseline%','18',n,dist); 

#compute weights of the burden share per quantile of damages and abatement
ineq_weights(t,n,dist,ineq_elast) = ( quantiles_ref(t,n,dist) ** el_coeff(ineq_elast) ) / sum(ddist, quantiles_ref(t,n,ddist) ** el_coeff(ineq_elast) ) ;

#calibrated xi to avoid negative decile incomes in worst case scenario
$if set use_calib ineq_weights(t,n,dist,'damages') = ineq_weights_calib(t,n,dist);

#calibrated omega elasticities from Budolfson 2021
$if set omegacalib ineq_weights(t,n,dist,'abatement') = ( quantiles_ref(t,n,dist) ** ( 3.3219 - 0.2334 * log(1e6 * ykali(t,n)/pop(t,n) ) ) ) / sum(ddist, quantiles_ref(t,n,ddist) ** (3.3219 - 0.2334 * log(1e6 * ykali(t,n)/pop(t,n))) )  ;

$if %transfer%=="neutral" ineq_weights(t,n,dist,'redist') = ineq_weights(t,n,dist,'abatement');

##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase DECLARE VARS, you can DECLARE new variables for your module.
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'

Variable YGROSS_DIST(t,n,dist);
Variable YNET_DIST(t,n,dist);
Variable Y_DIST_PRE(t,n,dist)  'GDP per quantile NET of Abatement Costs and Damages, pre-taxes (%exchange_rate%) [Trill 2005 USD / year]';
Variable Y_DIST(t,n,dist)            'GDP per quantile NET of Abatement Costs, Damages and taxes (%exchange_rate%) [Trill 2005 USD / year]';
Variable CPC_DIST(t,n,dist)          'Per capita quantile consumption (%exchange_rate%) [2005 USD per year per capita]'; 
Variable TRANSFER(t,n,dist);

#INITIALIZE VARIABLES
YGROSS_DIST.l(t,n,dist) = YGROSS.l(t,n)*quantiles_ref(t,n,dist);
YNET_DIST.l(t,n,dist) = YGROSS_DIST.l(t,n,dist);
Y_DIST_PRE.l(t,n,dist) = YGROSS_DIST.l(t,n,dist);
Y_DIST.l(t,n,dist) = YGROSS_DIST.l(t,n,dist);
CPC_DIST.l(t,n,dist) = 1e6 * Y_DIST.l(t,n,dist) * ( 1 - S.l(t,n) ) / ( pop(t,n) * quant_share(dist) );
TRANSFER.l(t,n,dist) = 0;
CTX.l(t,n) = EIND.l(t,n)*CPRICE.l(t,n)*1e-3;

##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
* DO NOT put VAR.l here! (use the declare_vars phase)
$elseif.ph %phase%=='compute_vars'

TRANSFER.lo(t,n,dist) = 0; #positive transfers only
YGROSS_DIST.lo(t,n,dist) = 0;

##  STABILITY CONSTRAINTS ------------------------------
* to avoid errors/help the solver to converge
$if set welfare_inequality Y_DIST.lo(t,n,dist) = 0; #y_dist_min(t,n,dist); #grant substistance levels to all quantiles 
$if set welfare_inequality CPC_DIST.lo(t,n,dist) = 1e-3; #needed for equation eq_welfare

#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
* List of equations
* One per line.
$elseif.ph %phase%=='eql'

    eq_ygrossdist
    eq_ynetdist_unbnd
    eq_ydist_unbnd
    eq_ydist
    eq_cpcdist
    eq_transfer
    eq_ctx        # total cost of carbon tax
    
##  EQUATIONS
#_________________________________________________________________________
* In the phase EQS, you can include new equations to the model.
* The equations are always included.
* Best practice : - condition your equation to be able to do a run with tfix(t)
$elseif.ph %phase%=='eqs'

* computes income w/o climate damages and abatement costs. 
eq_ygrossdist(t,n,dist)$reg(n)..    YGROSS_DIST(t,n,dist) =E= 
                                        quantiles_ref(t,n,dist) * YGROSS(t,n); 

* computes
eq_ynetdist_unbnd(t,n,dist)$reg(n).. 
                                    YNET_DIST(t,n,dist) =E=
                                        YGROSS_DIST(t,n,dist)                                         
                                        - DAMAGES(t,n) * ineq_weights(t,n,dist,'damages'); 

eq_ydist_unbnd(t,n,dist)$reg(n)..   Y_DIST_PRE(t,n,dist) =E=
                                        YNET_DIST(t,n,dist) -
$if not set ctax_marginal               ctax_corrected(t,n) * 1e-3 * (E(t,n) - E.l(t,n)) * quantiles_ref(t,n,dist) -
                                        ( ABATECOST(t,n) + CTX(t,n) ) * ineq_weights(t,n,dist,'abatement')
;                                         

eq_ydist(t,n,dist)$reg(n)..         Y_DIST(t,n,dist) =E=
                                        Y_DIST_PRE(t,n,dist) 
                                        + TRANSFER(t,n,dist);

eq_ctx(t,n)$reg(n)..                CTX(t,n) =E= CPRICE(t,n) * EIND(t,n) * 1e-3;

*computes consumption per capita per quantile
eq_cpcdist(t,n,dist)$reg(n)..       CPC_DIST(t,n,dist) =E= 
                                        1e6 * Y_DIST(t,n,dist)     
                                        * ( 1 - S(t,n) ) / ( pop(t,n) * quant_share(dist) );

*fix transfer to an exogenous shape
$ifthen.redist %transfer%=="opt"
eq_transfer(t,n)$reg(n)..            CTX(t,n)  =E= sum(dist, TRANSFER(t,n,dist));
$else.redist
eq_transfer(t,n,dist)$reg(n)..       TRANSFER(t,n,dist) =E= CTX(t,n) * ineq_weights(t,n,dist,'redist'); 
$endif.redist

*integrates mod inequality with the utility function
$ifthen.ut set welfare_inequality 
eq_utility_arg(t,n)$reg(n).. UTARG(t,n) =E= [( sum(dist, quant_share(dist) * CPC_DIST(t,n,dist) ** (1-gammaint)  ) **(1/(1-gammaint)) ) ];
$endif.ut                

##  FIX VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='fix_variables'

##  BEFORE SOLVE
#_________________________________________________________________________
* In the phase BEFORE_SOLVE, you can update parameters (fixed
* variables, ...) inside the nash loop and right before solving the
* model. This is typically done for externalities, spillovers, ...
* Best practice: record the variable that you update across iterations.
* Remember that you are inside the nash loop, so you cannot declare
* parameters, ...
$elseif.ph %phase%=='before_solve'

##  AFTER SOLVE
#_________________________________________________________________________
* In the phase AFTER_SOLVE, you compute what must be propagated across the
* regions after one bunch of parallel solving.
$elseif.ph %phase%=='after_solve'

*for SCC etc. recompute consumption marginal values to approximate from median
eq_cc.m(t,n) = eq_cpcdist.m(t,n,"D5")*1e6;

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================
##  REPORT
#_________________________________________________________________________
* Post-solve evaluate report measures
$elseif.ph %phase%=='report'

* report consumption per capita w/o climate change damages and abatement costs
Parameter cpcgross_dist(t,n,dist);
cpcgross_dist(t,n,dist) = 1000 * YGROSS_DIST.l(t,n,dist) * (1 - S.l(t,n)) / ( pop(t,n) * quant_share(dist) );

Parameter quantiles(t,n,dist);
quantiles(t,n,dist) = ( CPC_DIST.l(t,n,dist) * quant_share(dist) ) / ( CPC.l(t,n) );

Parameter abatecost_dist(t,n,dist);
abatecost_dist(t,n,dist) = ABATECOST.l(t,n) * ineq_weights(t,n,dist,'abatement'); 

$ifthen.cd set calib_damages
#needed for calib_damages
Parameter itermax /1e3/;
Parameter tol /1e-5/;
Parameters err,it;

Parameter y_dist_last(t,n,dist); 
Parameter y_dist_bounded(t,n,dist);
Parameter y_dist_red(t,n,dist); 
Parameter ineq_calib(t,n,dist);

* entry conditions into the while loop
y_dist_red(t,n,dist) = Y_DIST.l(t,n,dist);
it = 0;
err = 1;

* grant that climate change damages in a bau_impact cause at most y_dist to go to 0
while ( it < itermax and err > tol,
y_dist_last(t,n,dist) =  y_dist_red(t,n,dist);
y_dist_bounded(t,n,dist) = max(y_dist_min(t,n,dist), y_dist_last(t,n,dist));
y_dist_red(t,n,dist) = y_dist_bounded(t,n,dist) - sum(ddist,y_dist_bounded(t,n,ddist) - y_dist_last(t,n,ddist) ) * quant_share(dist) ;
err = smax( (t,n,dist), abs( ( y_dist_red(t,n,dist) - y_dist_last(t,n,dist) ) / y_dist_last(t,n,dist) ) );
it = it + 1;
);

ineq_calib(t,n,dist)$(year(t) le 2020) = ineq_weights(t,n,dist,'damages');
ineq_calib(t,n,dist)$(year(t) gt 2020) = (YGROSS_DIST.l(t,n,dist) - y_dist_red(t,n,dist)) / DAMAGES.l(t,n);
$endif.cd

##  GDX ITEMS
#_________________________________________________________________________
* List the items to be kept in the final gdx
$elseif.ph %phase%=='gdx_items'

quantiles_ref
quantiles
inequality_parameters
YGROSS_DIST
Y_DIST
CPC_DIST
TRANSFER
cpcgross_dist
ineq_weights
abatecost_dist
el_coeff
y_dist_min
gammaint

$if set calib_damages ineq_calib 
eq_cpcdist

$endif.ph



 modules/mod_land_use.gms

* MODULE LAND USE
* To assess how much emissions are coming from Land Use.
* Temporarily based on a distributed version of DICE2016 process.
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================
##  CONF
#_________________________________________________________________________
$ifthen.ph %phase%=='conf'


## SETS
#_________________________________________________________________________
$elseif.ph %phase%=='sets'

set yearlu /1850*2300/;

## INCLUDE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='include_data'

PARAMETERS
** LU-Baseline
   eland0(n)        'Carbon emissions from land in 2015 [GtCO2/year]'
   deland           'Decline rate of land emissions (per period)'         / .115  /
   eland_bau(*,t,n) 'Carbon emissions baselines from land [GtCO2/year]'
;

* Historical EMISSIONS
PARAMETER q_emi_valid_primap(*,yearlu,n)  'Historical Emissions per each region [GtC]';
PARAMETER q_emi_valid_oscar(*,yearlu,n)  'Historical Emissions per each region [GtC]';
$gdxin  '%datapath%data_historical_values'
$load   q_emi_valid_primap q_emi_valid_oscar
$gdxin


##  COMPUTE DATA
#_________________________________________________________________________
$elseif.ph %phase%=='compute_data'

* starting value averaged over last 10 year ( to minimize risk of high fluctuations)
eland0(n)  = CtoCO2 * sum(yearlu, q_emi_valid_oscar('co2lu',yearlu,n)$((yearlu.val ge 2005) and (yearlu.val lt 2015))) / 10  ;

loop(t,
* UNIFORM LOGIC
    eland_bau('uniform',t,n)  =  eland0(n)*(1-deland)**(t.val-1) ;
* DIFFERENTIATED
    # if negative, it remains fixed to its value
    # otherwise smmoth decreasing at DICE2016 rate.
    eland_bau('differentiated',t,n)  =  min(eland0(n)*(1-deland)**(t.val-1), eland0(n) ) ;
);

* global values
PARAMETER global_eland_bau(*,t);
  global_eland_bau('uniform',t)  = sum(n, eland_bau('uniform',t,n))    ;
  global_eland_bau('differentiated',t)  = sum(n, eland_bau('differentiated',t,n))   ;

PARAMETER cumeland_bau(*,t,n), global_cumeland_bau(*,t);
cumeland_bau('uniform','1',n)= 0;
cumeland_bau('differentiated','1',n)= 0;

loop(t,
 cumeland_bau('uniform', t+1, n) =  cumeland_bau('uniform', t, n) + eland_bau('uniform',t,n);
 cumeland_bau('differentiated', t+1, n) =  cumeland_bau('differentiated', t, n) + eland_bau('differentiated',t,n);
);

global_cumeland_bau('uniform',t) = sum(n, cumeland_bau('uniform',t,n)) ;
global_cumeland_bau('differentiated',t) = sum(n, cumeland_bau('differentiated',t,n)) ;


##  DECLARE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='declare_vars'

VARIABLES    ELAND(t,n)     'Land-use emissions   [GtCO2/year]';


##  COMPUTE VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='compute_vars'

$ifthen.lu '%policy%'=='bau'
# For BAU scenario take the DICE-like baselines (pessimistic)
ELAND.fx(t,n)  =  eland_bau('uniform',t,n)  ;
$elseif.lu '%policy%'=='bau_impact'
# For BAU-IMPACTS scenario take the DICE-like baselines (pessimistic)
ELAND.fx(t,n)  =  eland_bau('uniform',t,n)  ;
$else.lu
# For any other policy (mitigative) take more ambitious and realistic baselines
ELAND.fx(t,n)  =  eland_bau('differentiated',t,n)  ;
$endif.lu


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
$elseif.ph %phase%=='gdx_items'

# Parameters -------------------------------------------
eland0
deland

# Variables --------------------------------------------
ELAND


$endif.ph




 modules/mod_macc.gms

* MODULE MACC
*
* Marginal abatement cost curves.
* Comes after a rather elaborated fitting process based on EnerData data,
* and therefore deserves a self-standing module.
*____________
* REFERENCES
* - EnerData(c) 2017 MACCs
* - DICE 2016
*
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module
$ifthen.ph %phase%=='conf'

# MACC CURVES formula
* | ed | dice2016 |
$setglobal macc 'ed'


* CORRECTION MULTIPLIER
* | ssp2marker | advance | ssp2markerXT | advanceXT |
$setglobal mxdataref ssp2marker


# BACKSTOP DATA 
* (DICE2016 as default)
$setglobal pback      550
$setglobal gback      0.025
$setglobal expcost2   2.8
* time starting transition to pbackstop
$setglobal tstart_pbtransition   7
* time of full-convergence to backstop curve [18,38]
$setglobal tend_pbtransition   23
* parameter influencing logistic transition speed (0,2]
$setglobal klogistic 0.25
#........................
# Some reference times:
# 2020 -> t = 2
# 2040 -> t = 6
# 2050 -> t = 8
# 2100 -> t = 18
# 2125 -> t = 23
# 2150 -> t = 28
# 2200 -> t = 38
# 2250 -> t = 48
# 2300 -> t = 58
#.......................


# MACC SHAPE
* MACC fitting model | cstay14fit [polinomial 1-4] |
$setglobal maccfit "poly14fit"

## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing
* sets the element that you need.
$elseif.ph %phase%=='sets'

SETS

   coef    'fit coefficients for MACC'  / a, b /

   sector  'EnerData sectors'   /
        Total_CO2
        Total_CH4
        #Total_HFC
        Total_N2O
        #Total_PFC
        #Total_SF6
    /

   map_sector_ghg(sector,ghg) 'Relationships between Enerdata Sectors and GHG' /
        Total_CO2.co2
        Total_CH4.ch4
        #Total_HFC.hfc
        Total_N2O.n2o
        #Total_PFC.pfc
        #Total_SF6.sf6
    /

;

* MX alternative data references
SET mxdataref 'Rata-reference for macc multiplier calibration'/

        ssp2marker
        advance
        ssp2markerXT
        advanceXT
    /
;



## INCLUDE DATA
#_________________________________________________________________________
* In the phase INCLUDE_DATA you should declare and include all exogenous parameters.
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it
*                 - this is the only phase where we should have numbers...
$elseif.ph %phase%=='include_data'


##  PARAMETERS HARDCODED OR ASSIGNED ------------------- 

PARAMETERS
* DICE backstop
    expcost2  "Exponent of control cost function"                / %expcost2% / #DICE: 2.8
    pback     "Cost of backstop 2010$ per tCO2 in 2015"          / %pback%    / #DICE2013: 344     #DICE2016: 550
    gback     "Initial cost decline backstop cost per period"    / %gback%    / #DICE2013: 0.05    #DICE2016: 0.025
;



##  PARAMETERS OF DICE2016 ABATEMENT COST FUNCTION
PARAMETERS
** Participation parameters
    periodfullpart Period at which have full participation           /21  /  #DICE2013
    partfract2010  Fraction of emissions under control in 2010       / 1  /  #DICE2013
    partfractfull  Fraction of emissions under control at full time  / 1  /  #DICE2013
;


##  PARAMETERS LOADED ----------------------------------

* Correction multiplier calibrated
PARAMETER  MXkali(mxdataref)  "Correction multiplier calibrated over enerdata times"  ;
$gdxin '%datapath%data_mod_macc_correcting_factor'
$load  MXkali
$gdxin


* CO2 MAC-Curves fitting parameters
PARAMETER  macc_%maccfit%_enerdata_CO2(sector,coef,t,n)  'EnerData CO2 MACC -fit with %maccfit%- for given years (2025-2040)'  ;
$gdxin '%datapath%data_macc_ed_co2perc_fit'
$load  macc_%maccfit%_enerdata_CO2    = abat_coef_enerdata_%maccfit%
$gdxin


* OGHG MAC-Curves fitting parameters
$ifthen.oghg %climate% == 'witchoghg'
PARAMETER  macc_fitcoef_enerdata_OGHG(sector,coef,t,n)  'EnerData OGHG MACC fit for given years (2025-2040)'  ;
$gdxin '%datapath%data_macc_enerdata_OGHG'
$load  macc_fitcoef_enerdata_OGHG = abat_coef_enerdata
$gdxin
$endif.oghg


##  PARAMETERS EVALUATED -------------------------------

PARAMETERS
* Backstop
    pbacktime(t)            "Backstop price"
    cost1(t,n)              "Adjusted cost for Backstop"
    partfract(t)            "Fraction of emissions in control regime"
* MACC fit coefficients
    ax_co2(*,sector,t,n)    "EnerData < a > %maccfit%-coeff for MACC"
    bx_co2(*,sector,t,n)    "EnerData < b > %maccfit%-coeff for MACC"
    a_oghg(sector,t,n)      "EnerData < a > fit-coeff for MACC"
    b_oghg(sector,t,n)      "EnerData < b > fit-coeff for MACC"
* MACC transition
    mx(t,n)                 "Enerdata MACC multiplier calibated on diagnostics"
    alpha(t)                "Transition to backstop coefficient"
    MXpback(t,n)            "MX to obtain full pbackstop"
    MXstart(n)              "MX starting value"
    MXend(t,n)              "MX value to be reached"
    MXdiff(t,n)             "MX transition gap"
;





##  COMPUTE DATA
#_________________________________________________________________________
* In the phase COMPUTE_DATA you should declare and compute all the parameters
* that depend on the data loaded in the previous phase.
$elseif.ph %phase%=='compute_data'



# MACC fit-coefficients --------------------------------

ax_co2('%maccfit%','Total_CO2',t,n)    = macc_%maccfit%_enerdata_CO2('Total_CO2', 'a', t, n);
bx_co2('%maccfit%','Total_CO2',t,n)    = macc_%maccfit%_enerdata_CO2('Total_CO2', 'b', t, n);


$ifthen.oghg %climate% == 'witchoghg'
a_oghg(sector,t,n)     = macc_fitcoef_enerdata_OGHG(  sector  , 'a', t, n);
b_oghg(sector,t,n)     = macc_fitcoef_enerdata_OGHG(  sector  , 'b', t, n);
$endif.oghg


#  PBackstop curve -------------------------------------
pbacktime(t)  =  pback*(1-gback)**(t.val-1);
cost1(t,n)    =  pbacktime(t)*sigma(t,n)/expcost2/1000;



# TRANSITION TO BACKSTOP -------------------------------
* It is directly related to settings from conf phase.
* Shape, slope and convergence time are all taken into account here

## logistic pbtransition
scalar x0 ;
x0 = %tstart_pbtransition% + ((%tend_pbtransition%-%tstart_pbtransition%)/2)  ;
alpha(t) = 1/(1+exp(-%klogistic%*(t.val-x0)));



# BACKSTOP MULTIPLIER ----------------------------------

# NOTE .....................................................................
# Following evaluations give answer to the question:
# Which multiplier would make my full-abatement MACcurve (MIU=1) coincide
# to the previously-evaluated pbackstop (in every time-step)?
#...........................................................................

# Mx = back_end / (a bau + b bau^4)  -->  MIU = 1
MXpback(t,n)  =  pbacktime(t)
                /  ((ax_co2('%maccfit%','Total_CO2',t,n) * 1)  +  (bx_co2('%maccfit%','Total_CO2',t,n) * power(1,4)))  ;


# NOTE ........................................................................
# Before transition the original multiplier applies,
# then a smooth  transition to the pback-curve is performed,
# by progressively reducing the distance (according to the shaping alpha-param)
#...............................................................................

MXstart(n)   =  MXkali('%mxdataref%')  ;
MXend(t,n)   =  MXpback(t,n)  ;
MXdiff(t,n)  =  max( MXstart(n)  - MXend(t,n),0) ;

* Final coefficient values:
mx(t,n)      =  MXstart(n)  -  alpha(t) * MXdiff(t,n);




##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase VARS, you can DECLARE new variables for your module.
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'

VARIABLES
   ABATECOST(t,n)    'Cost of emissions reductions [Trill 2005 USD / year]'
   CPRICE(t,n)       'Carbon Price [ 2005 USD /tCO2 ]'
   ABATECOST_OGHG(oghg,t,n)    'Cost of oghg emissions reductions [Trill 2005 USD / year]'
;

POSITIVE VARIABLES ABATECOST, CPRICE, ABATECOST_OGHG;

# VARIABLES STARTING LEVELS ----------------------------
ABATECOST.l(t,n) = 0 ;
   CPRICE.l(t,n) = 0 ;

##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
$elseif.ph %phase%=='compute_vars'


#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================



##  EQUATION LIST
#_________________________________________________________________________
* List of equations
* One per line.
$elseif.ph %phase%=='eql'

    eq_abatecost      # Cost of emissions reductions equation'
    eq_cprice         # Carbon price equation'

$if %climate% == 'witchoghg'  eq_abatecost_oghg   # Cost of oghg emissions reductions equation


##  EQUATIONS
#_________________________________________________________________________
* In the phase EQS, you can include new equations to the model.
* The equations are always included.
* Best practice : - condition your equation to be able to do a run with t_fix(t)
$elseif.ph %phase%=='eqs'


$ifthen.macc %macc%=="ed"

* Abatement Cost ::   mx * (a(x^2)/2 + b(x^5)/5) * bau   :: [$/tCO2]x[GtCO2] ->  [ G$ ]
eq_abatecost(t,n)$(reg(n))..
                              #   Correction coefficient
          ABATECOST(t,n)  =E=  mx(t,n)
                              #   Tay14 integral
                              *   ((ax_co2('%maccfit%','Total_CO2',t,n)*power(MIU(t,n),2)/2)  +  (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU(t,n),5)/5))
                              #   Baseline emissions (due to miu-based integral) [GtCO2]
                              *   emi_bau_co2(t,n)
                              #   Coversion:  [ G$ ] / 1000 -> [Trill $]
                              /   1000
;                             # >> Costs will result in [Trill USD]



* Carbon Price ::   y ~ mx (ax + bx^4)
eq_cprice(t,n)$(reg(n))..
                              #   Correction coefficient
             CPRICE(t,n)  =E=  mx(t,n)
                              #   Taylor14 formulation
                              *   ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU(t,n),4)))
;                             # >> CPrice will result in [$/tCO2] by construction


* :::::  ABATE COSTS AND CPRICE FROM ENERDATA OGHG MACCs  ::::: *
** OGHG ABATECOSTS
$ifthen.oghg %climate% == 'witchoghg'
 eq_abatecost_oghg(oghg,sector,t,n)$(reg(n) and  map_sector_ghg(sector,oghg))..
                                  # Powerfit Abatement Cost:  [ USD/tCO2eq_max_abat ] :  a (MIU^(b+1)) / (b+1)
   ABATECOST_OGHG(oghg,t,n)  =E=  ED_a_oghg(sector,t,n)*(MIU_OGHG(oghg,t,n)**(ED_b_oghg(sector,t,n) +1)) / (ED_b_oghg(sector,t,n) +1)
                                  # Baseline emissions   [ GtCo2eq ]
                              *   oghg_emi_bau(oghg,t,n)
                                  # Coversion result     [ G$/1000 = Trill$ ]
                              /   1000   ;
$endif.oghg

$elseif.macc %macc%=="dice2016"
** ABATECOST AND CPRICE AS IN ORIGINAL DICE2016
eq_abatecost(t,n)$(reg(n))..
             ABATECOST(t,n)  =E=  YGROSS(t,n) * cost1(t,n) * (MIU(t,n)**expcost2)
;

eq_cprice(t,n)$(reg(n))..
                CPRICE(t,n)  =E=  pbacktime(t) * (MIU(t,n))**(expcost2-1)
;
$endif.macc

#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  GDX ITEMS
#_________________________________________________________________________
* List the items to be kept in the final gdx
$elseif.ph %phase%=='gdx_items'


# Parameters -----------------------------
pback
gback
expcost2
pbacktime
mx
cost1
ax_co2
bx_co2
alpha

# Variables ------------------------------

ABATECOST
CPRICE


$endif.ph 



 modules/mod_srm.gms

*------------------------------------------------------------------------
* Module Geoengineering by SRM via SO2 injection
* Additional changes required in mod_climate (* Total radiative forcing) and reg_model
* v2: for new mode, January 2015
*-------------------------------------------------------------------------

$ifthen.ph %phase%=='conf'

*Period in which SRM becomes available
$setglobal geoeng_start 2035
*if only one region is allowed to implement SRM
*$setglobal only_region nde

*multiple SRM regions can be activated with the flag 
*setglobal multiple_regions filename_where_regions_are_listed

*maximum amount of SRM per region (in MtS)
$setglobal maxsrm 2

*Activate damages from SRM
$setglobal damage_geoeng
$setglobal impsrm_exponent 2 #exponent of damage function
$setglobal damage_geoeng_amount 0.03
*$setglobal srm_ub data_geoeng_upperbound #flag for setting an exogenous upper bound on srm

*------------------------------------------------------------------------
$elseif.ph %phase%=='sets'

set srm_available(t, n) 'periods and regions where SRM is available and used';

$ifthen.multiregion set multiple_regions
set n_active(n) 'Regions where srm can be used' /
$include %datapath%%multiple_regions%.inc
/;
$endif.multiregion

$ifthen.coal set onlysrmcoalition
set n_active(n);
$setglobal swf bge_regional
$endif.coal

*------------------------------------------------------------------------
$elseif.ph %phase%=='include_data'

* In the phase INCLUDE_DATA you should declare and include all your exogenous parameters.
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it
*                 - this is the only phase where we should have numbers...

* Costs: 5 (Robock 2009) - 25 (Cruzen 2006) billion US/TgS
* Forcing: -0.5 (Cruzen 2006) up to -2.5 (Rasch 2008) W/m^2/TgS (see also Gramstad and Tjotta (2010)
* Atmospheric residence time: not relevant for dynamics due to 5 year time step, but lowers cost!
* 1Tg = 1MT. 1gr S = 2gr SO2
Parameters
                        srm_cost_tgs        'costs in billion USD per TgS'          / 10 /
                        geoeng_forcing          'negative forcing per TgS'          / -1.75 /
                        geoeng_residence_in_atm 'atmospheric residence time'            / 2 /
;
* compute actual cost per year taking into account the atmospheric residence time, disregarding initialisation.
* convert billions into T$ (trillions USD) by dividing by 1000.
*SRM_COST_tgs=(SRM_COST_tgs/geoeng_residence_in_atm)/1000 ;

parameter wsrm(t)     'World SRM SO2 injections';

parameter damage_geoeng_amount(n);
damage_geoeng_amount(n) = %damage_geoeng_amount%;

$ifthen.ub set srm_ub
parameter geoeng_ub(t,n)    'upper bound for SRM for convergence';
$gdxin '%datapath%%srm_ub%.gdx'
$load   geoeng_ub=geoeng_upperbound
$gdxin
$endif.ub

$if set all_data_temp parameter srm_iter(t,n,iter);


*------------------------------------------------------------------------
$elseif.ph %phase%=='compute_data'

*------------------------------------------------------------------------
$elseif.ph %phase%=='declare_vars'

Variable SRM(t,n) 'TgS injected into the atmosphere';
SRM.lo(t,n)=0;
*start from zero
SRM.l(t,n)=0;

*now instead randomize
$ifthen.rnd set randomsrminit
execseed = 1 + gmillisec(jnow);
parameter srm_init(n);
srm_init(n) = Uniform(0,0.5);
SRM.l(t,n) = srm_init(n);
$endif.rnd
$if set init_region SRM.l(t,'%init_region%')=2;

Variable SRM_COST(t,n)  'Costs of Geoengineering in trillion USD';

Variable W_SRM(t,n);
W_SRM.lo(t,n) = 0;


*------------------------------------------------------------------------
$elseif.ph %phase%=='compute_vars'
* The phase BEFORE_NASHLOOP is situated just before the loop solving an equilibrium

SRM.lo(t, n) = 0;

*determine by whom and when SRM is admissible
*only after 2050
srm_available(t,n)$(year(t) ge %geoeng_start% and year(t) le 2250) = YES;

* only one region
$if set only_region srm_available(t,n)$(not sameas(n, '%only_region%')) = NO;
* multiple regions
$if set multiple_regions  srm_available(t,n)$(not n_active(n)) = NO;

* COALITIONS
*$set global onlysrmcoalition
$ifthen.coal set onlysrmcoalition
n_active(n) = yes$map_clt_n('srm_coalition',n);
srm_available(t,n)$(not n_active(n)) = NO;
$endif.coal


* To start with, no Geoengineering possible
SRM.fx(t, n)$(not srm_available(t,n))=0;
SRM.l(t, n)$(not srm_available(t,n))=0;
*W_SRM.fx(t, n)$(not srm_available(t,n))=0;

*everyone can do it (or limited Geoengineering to x<1 Tg per year)
SRM.up(t, n)$(srm_available(t,n))=%maxsrm%;

$if set srm_ub SRM.up(t,n)$(srm_available(t,n))=geoeng_ub(t,n);


* recompute climate and damages based on the new W_SRM.l
wsrm(t) = sum(n, SRM.l(t,n));
W_SRM.l(t,n) =  wsrm(t);


*------------------------------------------------------------------------------
$elseif.ph %phase%=='eql'

* List of equations
eq_srm_cost
eqw_srm
*------------------------------------------------------------------------------
$elseif.ph %phase%=='eqs'

** Geoeng impacts from Goes et al 2011
eq_srm_cost(t,n)$(reg(n))..
                   SRM_COST(t, n) =e= ((srm_cost_tgs/geoeng_residence_in_atm)/1000) * (SRM(t, n)**%impsrm_exponent%);

eqw_srm(t,n)$(reg(n))..
                W_SRM(t,n) =e= wsrm(t) + sum(nn$reg(nn), SRM(t,nn) - SRM.l(t,nn));


*------------------------------------------------------------------------
$elseif.ph %phase%=='before_solve'
$if set dynamic_up SRM.up(t, n)$(srm_available(t,n))=%maxsrm%*(1-exp(-%dynamic_up%*ord(iter)));
wsrm(t) = sum(n, SRM.l(t,n));
*------------------------------------------------------------------------
$elseif.ph %phase%=='after_solve'
* Debug option, will store all the iteration in the parameter srm_iter
$if set all_data_temp srm_iter(t,n,iter) = SRM.l(t,n);
*------------------------------------------------------------------------
$elseif.ph %phase%=='after_nashloop'
* In the phase AFTER_NASHLOOP, you compute parameters needed for the report, once the job is ready.
* Best practice : - you should not declare parameters as this phase might be inside a loop

* recompute climate and damages based on the new W_SRM.l
wsrm(t) = sum(n, SRM.l(t,n));
W_SRM.l(t,n) =  wsrm(t);
*recompute climate module
$batinclude 'modules/hub_climate'

$elseif.ph %phase%=='gdx_items'
* List the items to be kept in the final gdx
SRM
SRM_COST
wsrm
W_SRM
srm_available

$endif.ph



 modules/mod_template.gms

# MODULE TEMPLATE
*
* Short description 
#____________
# REFERENCES
* - 
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module 
$ifthen.ph %phase%=='conf'


## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing 
* sets the element that you need.
$elseif.ph %phase%=='sets'




## INCLUDE DATA
#_________________________________________________________________________
* In the phase INCLUDE_DATA you should declare and include all exogenous parameters. 
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it 
*                 - this is the only phase where we should have numbers...
$elseif.ph %phase%=='include_data'


##  COMPUTE DATA
#_________________________________________________________________________
* In the phase COMPUTE_DATA you should declare and compute all the parameters 
* that depend on the data loaded in the previous phase. 
$elseif.ph %phase%=='compute_data'



##  DECLARE VARIABLES
#_________________________________________________________________________
* In the phase DECLARE VARS, you can DECLARE new variables for your module. 
* Remember that by modifying sets, you already have some variables for free.
$elseif.ph %phase%=='declare_vars'



##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
$elseif.ph %phase%=='compute_vars'



#=========================================================================
*   ///////////////////////     OPTIMIZATION    ///////////////////////
#=========================================================================

##  EQUATION LIST
#_________________________________________________________________________
* List of equations
* One per line.
$elseif.ph %phase%=='eql'


##  EQUATIONS
#_________________________________________________________________________
* In the phase EQS, you can include new equations to the model.
* The equations are always included.
* Best practice : - condition your equation to be able to do a run with tfix(t) 
$elseif.ph %phase%=='eqs'


##  FIX VARIABLES
#_________________________________________________________________________
$elseif.ph %phase%=='fix_variables'
* This phase is done after the phase POLICY.
* You should fix all your new variables.



##  BEFORE SOLVE
#_________________________________________________________________________
* In the phase BEFORE_SOLVE, you can update parameters (fixed
* variables, ...) inside the nash loop and right before solving the
* model. This is typically done for externalities, spillovers, ...
$elseif.ph %phase%=='before_solve'

##  AFTER SOLVE
#_________________________________________________________________________
* In the phase AFTER_SOLVE, you compute what must be propagated across the 
* regions after one bunch of parallel solving.
$elseif.ph %phase%=='after_solve'


#===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
#===============================================================================

##  REPORT
#_________________________________________________________________________
* Post-solve evaluate report measures
$elseif.ph %phase%=='report'


##  GDX ITEMS
#_________________________________________________________________________
* List the items to be kept in the final gdx
$elseif.ph %phase%=='gdx_items'


$endif.ph



 modules/pol_ndc.gms

# MODULE TEMPLATE
*
* Short description 
#____________
# REFERENCES
* - 
#=========================================================================
*   ///////////////////////       SETTING      ///////////////////////
#=========================================================================

##  CONF
#_________________________________________________________________________
* Definition of the global flags and settings specific to the module 
$ifthen.ph %phase%=='conf'

* NDCs extrapolation: | no | const | linear | hotelling |
$setglobal ndcs_extr "linear"

$setglobal nameout "%baseline%_ndc%ndcs_type%_%cooperation%_extr%ndcs_extr%"
$setglobal output_filename results_%nameout%

*MIU is fixed up to 2030, by default other policies start in 2035
$setglobal ctax_start 2035

## SETS
#_________________________________________________________________________
* In the phase SETS you should declare all your sets, or add to the existing 
* sets the element that you need.
$elseif.ph %phase%=='sets'

Set tmiufix(t) "Time periods of fixed mitigation levels" /1,2,3,4/;


## INCLUDE DATA
#_________________________________________________________________________
* In the phase INCLUDE_DATA you should declare and include all exogenous parameters. 
* You can also modify the data loaded in data.gms
* Best practice : - create a .gdx containing those and to loading it 
*                 - this is the only phase where we should have numbers...
$elseif.ph %phase%=='include_data'

parameter cprice_hotel(t,n);
cprice_hotel(t,n)=0;

##  COMPUTE VARIABLES
#_________________________________________________________________________
* In the phase COMPUTE_VARS, you fix starting points and bounds.
* DO NOT put VAR.l here! (use the declare_vars phase) 
$elseif.ph %phase%=='compute_vars'

$if %policy%=="bau" MIU.lo(t,n)$(not tmiufix(t))=0; MIU.up(t,n)$(not tmiufix(t))=max_miu; #undo MIU fix to allow for NDCs continuation
MIU.fx(t,n)$tmiufix(t) = miu_fixed_levels(t,n); # Fixing mitigation variable in 2015-2030 period; .lo if NDCs are meant as a minumum mitigation effort
CPRICE.lo(t,n)$tmiufix(t) = mx(t,n)* ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU.lo(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU.lo(t,n),4))); #needed for recomputation of ctax_corrected

##  BEFORE SOLVE
#_________________________________________________________________________
* In the phase BEFORE_SOLVE, you can update parameters (fixed
* variables, ...) inside the nash loop and right before solving the
* model. This is typically done for externalities, spillovers, ...
$elseif.ph %phase%=='before_solve'

$ifthen.ndc %ndcs_extr%=="const"

CPRICE.lo(t,n)$(year(t) gt 2030) =  min(CPRICE.l('4',n), mx(t,n)* ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU.up(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU.up(t,n),4))) );

$elseif.ndc %ndcs_extr%=="linear"

CPRICE.lo(t,n)$(year(t) gt 2030 and CPRICE.l('2',n) ne 0) =  min(CPRICE.l('4',n) * (1 + (CPRICE.l('4',n) - CPRICE.l('2',n))/(CPRICE.l('4',n)*tstep*2) * (year(t) - 2030) ) , mx(t,n)* ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU.up(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU.up(t,n),4))) );

$elseif.ndc %ndcs_extr%=="hotelling"

cprice_hotel('4',n) = CPRICE.l('4',n);
loop( (t,tt)$pre(tt,t),
cprice_hotel(t,n)$(year(t) gt 2030)=cprice_hotel(tt,n) * (1 + prstp + elasmu * (ykali(t,n)-ykali(tt,n))/(tstep*ykali(tt,n)) ) ** tstep );
CPRICE.lo(t,n)$(year(t) gt 2030) = min(cprice_hotel(t,n), mx(t,n)* ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU.up(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU.up(t,n),4))) );

$endif.ndc

* Recompute ctax corrected to avoid inconsistencies with NDCs
ctax_corrected(t,n) = max(CPRICE.lo(t,n), min(ctax(t,n)*1e3, 
                            mx(t,n)* ((ax_co2('%maccfit%','Total_CO2',t,n)*MIU.up(t,n)) + (bx_co2('%maccfit%','Total_CO2',t,n)*power(MIU.up(t,n),4))) ) );


##  GDX ITEMS
#_________________________________________________________________________
* List the items to be kept in the final gdx
$elseif.ph %phase%=='gdx_items'

miu_fixed_levels
miu_ndcs_2030

$endif.ph



 modules.gms

$set phase %1

$batinclude 'modules/core_time'                                         %2 # Core block to align correctly time epriods
$batinclude 'modules/core_regions'                                      %2 # Regions settings and exogenous data imports

$batinclude 'modules/core_economy'                                      %2 # Core block for economy
$batinclude 'modules/core_emissions'                                    %2 # Core block for emissions
$batinclude 'modules/core_welfare'                                      %2 # Core block for welfare

$batinclude 'modules/cooperation_%cooperation%'                          %2 # Cooperation setup
$batinclude 'modules/core_algorithm'                                    %2 # Solve settings

$batinclude 'modules/mod_macc'                                          %2 # MAC curves, abatement cost
$batinclude 'modules/mod_land_use'                                      %2 # Land-use HUB
$batinclude 'modules/hub_climate'                                       %2 # Climate  HUB
$batinclude 'modules/mod_climate_regional'                              %2 # Regional climate module
$batinclude 'modules/hub_impact'                                        %2 # Climate Impact  HUB


# POLICY
$batinclude 'modules/core_policy'                                       %2 # All policy options
$if set pol_ndc $batinclude 'modules/pol_ndc'                           %2 # NDC policy module

# Optional Modules
$if set mod_adaptation $batinclude 'modules/mod_adaptation'             %2 # Adaptation Module
$if set mod_government $batinclude 'modules/mod_government'             %2 # Government Module
$if set mod_labour $batinclude 'modules/mod_labour'                     %2 # Labour Module
$if set mod_inequality $batinclude 'modules/mod_inequality'             %2 # Inequality Module
$if set mod_srm $batinclude 'modules/mod_srm'                           %2 # Solar Radiation management Module
$if set mod_slr $batinclude 'modules/mod_slr'                           %2 # Sea level rise Module
$if set mod_natural_capital $batinclude 'modules/mod_natural_capital'   %2 # Nature Capital Green Module
$if set mod_emission_pulse $batinclude 'modules/mod_emission_pulse'     %2 # Emission Pulse for SCC computation
$if set mod_dac $batinclude 'modules/mod_emi_stor'                      %2 # Emission storage module
$if set mod_dac $batinclude 'modules/mod_dac'                           %2 # Negative emissions module



 run_rice50x.gms

$title  RICE50+
$onmulti
$setenv gdxcompress 1
$onrecurse
$eolcom #
$ontext
          _           __________
    _____(_)_______  / ____/ __ \  __
   / ___/ / ___/ _ \/___ \/ / / /_/ /_
  / /  / / /__/  __/___/ / /_/ /_ x__/
 /_/  /_/\___/\___/_____/\____/ /_/

This is an extension of the DICE-2016 model, with 57 regions.
The model includes SSP-based scenarios, alternative and interchangeable damage
functions, cooperation options, climate modules, etc.
$offtext
scalar starttime; starttime = jnow;

*=========================================================================
*   ///////////////////////       SETTINGS      ///////////////////////
*=========================================================================
* REGION DEFINITION
*| ed57 | witch17 | r5 | global |
$setglobal n 'ed57'

* BASELINE SCENARIO
*| ssp1 | ssp2 | ssp3 | ssp4 | ssp5 |
$setglobal baseline 'ssp2'

* POLICY
* | bau | bau_impact | cba | cbudget | cbudget_regional | ctax | simulation | simulation_tatm_exogen | simulation_climate_regional_exogen |
$setglobal policy 'bau'

* COOPERATION
* | coop | noncoop | coalitions
$setglobal cooperation 'noncoop'

* IMPACT SPECIFICATION
* | off | dice | burke | dell | kalkuhl | howard | climcost | coacch |
$setglobal impact 'kalkuhl'

* CLIMATE MODULE
* | dice2016 | cbsimple | witchco2 | witchoghg |
$setglobal climate 'witchco2'

* SAVINGS RATE
* | fixed | flexible |
$setglobal savings 'fixed'

* DEFAULT RESULTS FILENAME if nameout is not set
$setglobal nameout "%baseline%_%policy%"


*=========================================================================
**  DATA PATH DEFINITION
$setglobal datapath  data_%n%/
** Results path
$ifthen not set workdir
$setglobal resdir "%gams.curdir%"
$else
$setglobal resdir "%workdir%\"
$if %system.filesys% == UNIX $setglobal resdir "%workdir%/"
$endif
** DEBUG OPTIONS
*$setglobal onlysolve usa
*$setglobal all_data_temp #to create an all_data_temp_%nameout%.gdx file after each iteration

*=========================================================================
*   ///////////////////////     SETUP    ///////////////////////
*=========================================================================

* Model configuration across all modules
$batinclude "modules" "conf"

** Results filename
$setglobal output_filename results_%nameout%

* Model definition through phases
$batinclude "modules" "sets"
$batinclude "modules" "include_data"
$batinclude "modules" "compute_data"
$batinclude "modules" "declare_vars"

* Fixing model bounds
$batinclude "modules" "compute_vars"



*=========================================================================
*   /////////////////////////     EXECUTION    ///////////////////////
*=========================================================================

$batinclude "algorithm"

*===============================================================================
*     ///////////////////////     REPORTING     ///////////////////////
*===============================================================================

* Evaluate reporting measures
$batinclude "modules" "report";

* Time elapsed for execution
scalar elapsed; elapsed = (jnow - starttime)*24*3600;
#Just for quick analysis display a few values
Parameters tatm2100, world_damfrac2100, gdp2100;
tatm2100=TATM.l('18');
world_damfrac2100=world_damfrac('18');
gdp2100=sum(n,YNET.l('18',n));
display tatm2100,gdp2100,world_damfrac2100,elapsed;

* PRODUCE RESULTS GDX
execute_unload "%resdir%/%output_filename%.gdx"
$batinclude "modules" "gdx_items"
;